var documenterSearchIndex = {"docs":
[{"location":"secondary_structure/#secondary-structure","page":"Secondary structures","title":"Secondary structure","text":"","category":"section"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"These functions provide an interface to compute the secondary structure assignment of proteins using the STRIDE and DSSP algorithms, using as inputs vectors of PDBTools.Atoms.","category":"page"},{"location":"secondary_structure/#ProteinSecondaryStructures.stride_run","page":"Secondary structures","title":"ProteinSecondaryStructures.stride_run","text":"stride_run(atoms::AbstractVector{<:PDBTools.Atom})\n\nRun STRIDE secondary structure assignment on the provided array of atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> atoms[1458].name = \"O\"; # Terminal residue has non-standard atom name\n\njulia> ss = stride_run(atoms)\n104-element Vector{SSData}:\n SSData(\"ALA\", \"A\", 1, \"C\", 360.0, 64.07)\n SSData(\"CYS\", \"A\", 2, \"T\", -36.7, 125.51)\n SSData(\"ASP\", \"A\", 3, \"T\", -125.56, -10.38)\n ⋮\n SSData(\"CYS\", \"A\", 103, \"C\", -56.48, -168.79)\n SSData(\"THR\", \"A\", 104, \"C\", -110.75, 360.0)\n\n\n\n\n\n","category":"function"},{"location":"secondary_structure/#ProteinSecondaryStructures.dssp_run","page":"Secondary structures","title":"ProteinSecondaryStructures.dssp_run","text":"dssp_run(atoms::AbstractVector{<:PDBTools.Atom})\n\nRun DSSP secondary structure assignment on the provided array of atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> atoms[1458].name = \"O\"; # Terminal residue has non-standard atom name\n\njulia> ss = dssp_run(atoms)\n104-element Vector{SSData}:\n SSData(\"ALA\", \"A\", 1, \" \", 0.0, 64.1)\n SSData(\"CYS\", \"A\", 2, \" \", -36.7, 125.5)\n SSData(\"ASP\", \"A\", 3, \" \", -125.6, -10.4)\n ⋮\n SSData(\"CYS\", \"A\", 103, \" \", -56.5, -168.8)\n SSData(\"THR\", \"A\", 104, \" \", -110.7, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"The stride_run and dssp_run functions return a vector of SSData objects, each containing the secondary structure assignment and backbone dihedral angles for each residue.","category":"page"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"These functions return a vector of SSData objects, as defined in ProteinSecondaryStructures.jl. The secondary structure assignment codes are available  in the ProteinSecondaryStructures.jl documentation.","category":"page"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"note: Note\nNon-standard residue or atom names may lead to incorrect secondary structure assignments. To ensure accurate results, it is recommended to replace non-standard names with their standard three-letter codes before running these functions, and to verify that all backbone atoms (N, CA, C, O) are present in each residue. Errors or warnings will be issued if residue names are not recognized or backbone atoms are missing.","category":"page"},{"location":"secondary_structure/#Example-using-STRIDE","page":"Secondary structures","title":"Example using STRIDE","text":"","category":"section"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"The stride_run function runs the STRIDE algorithm on the provided array of atoms.","category":"page"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"using PDBTools\natoms = read_pdb(PDBTools.TESTPDB, \"protein\")\nss = stride_run(atoms)","category":"page"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"To run with DSSP just use the dssp_run function instead. ","category":"page"},{"location":"secondary_structure/#Utility-functions","page":"Secondary structures","title":"Utility functions","text":"","category":"section"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"PDBTools also reexports the ss_composition , ss_name, ss_code, ss_number of ProteinSecondaryStructures.jl, which can be used to analyze the secondary structure assignment results. For example, to compute the secondary structure composition from the ss vector obtained above:","category":"page"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"ss_composition(ss)","category":"page"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"ss_name(ss[1]) # name of the secondary structure of the first residue","category":"page"},{"location":"secondary_structure/","page":"Secondary structures","title":"Secondary structures","text":"For further information refer to to ProteinSecondaryStructures.jl documentation.","category":"page"},{"location":"help/#Help-entries","page":"Help entries","title":"Help entries","text":"","category":"section"},{"location":"help/","page":"Help entries","title":"Help entries","text":"The help entries for each function can be accessed from the Julia REPL by typing ?, for example,","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"julia> ? mass\nsearch: mass mapslices MathConstants makedocs set_zero_subnormals get_zero_subnormals mutable struct\n\n  mass(name::String or atom::Atom or Vector{<:Atom})\n\n  Returns the mass of an atom given its name, or Atom structure, or the total mass of a vector of Atoms.\n\n  Example\n  –––––––––\n\n  julia> atoms = [ Atom(name=\"NT3\"), Atom(name=\"CA\") ];\n  \n  julia> mass(atoms[1])\n  14.0067\n  \n  julia> mass(\"CA\")\n  12.011\n  \n  julia> mass(atoms)\n  26.017699999999998\n","category":"page"},{"location":"mvalue/#mvalues","page":"m-values","title":"m-value (protein transfer free energy) calculator","text":"","category":"section"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"m-values are the transfer free-energy difference, here in kcal/mol, between two structures from water to a 1M solution of a cosolvent.","category":"page"},{"location":"mvalue/#PDBTools.mvalue","page":"m-values","title":"PDBTools.mvalue","text":"mvalue(\n    sasa_initial::SASA{3,<:AbstractVector{<:Atom}},    \n    sasa_final::SASA{3,<:AbstractVector{<:Atom}},\n    cosolvent::String;\n    sel::Union{String,Function}=all,\n    model::Type{<:MValueModel}=AutonBolen,\n    backbone::Function = isbackbone,\n    sidechain::Function = issidechain,\n    parallel:Bool = true,\n)\n\nCalculates the m-value (transfer free energy of a protein in 1M solution, in kcal/mol) using the Tanford transfer model, as implemented by Moeser and Horinek [1] or by Auton and Bolen [2,3].\n\nPositional Arguments\n\nsasa_initial::SASA{3,<:AbstractVector{<:Atom}}: SASA object representing the initial state (e.g., native state).\nsasa_final::SASA{3,<:AbstractVector{<:Atom}}: SASA object representing the final state (e.g., denatured state).\ncosolvent::String: The cosolvent to consider. One of: \"betaine\", \"proline\", \"sarcosine\", \"sorbitol\", \"sucrose\", \"tmao\", \"urea\", \"urea-app\", \"urea-mh\" (case insensitive).\n\nKeyword Arguments\n\nsel::Union{String,Function}=all: Selection of atoms to consider in the calculation. Can be a selection string or a function that takes an Atom and returns a Bool.\nmodel::Type{<:MValueModel}=AutonBolen: The model to use for the calculation. Either MoeserHorinek or AutonBolen.\nbackbone::Function = PDBTools.isbackbone: Function to identify backbone atoms.\nsidechain::Function = PDBTools.issidechain: Function to identify side chain atoms.\nparallel:Bool = true: Set parallelization, requires starting Julia multithreaded.\n\nReturns\n\nA MValue object, with fields:\n\nntatoms::Int: Number of atoms considered.\ntot::Float32: Total m-value (kcal/mol/M).\nbb::Float32: Backbone contribution to the m-value (kcal/mol/M).\nsc::Float32: Side chain contribution to the m-value (kcal/mol/M).\nresidue_contributions_bb::Vector{Float32}: Backbone contributions of each residue to the m-value.\nresidue_contributions_sc::Vector{Float32}: Side-chain contributions of each residue to the m-value.\n\nExample\n\nusing PDBTools\n\ninitial_state = read_pdb(\"native.pdb\")\nfinal_state = read_pdb(\"desnat.pdb\")\n\nsasa_initial = sasa_particles(initial_state)\nsasa_final = sasa_particles(final_state)\n\nmvalue(sasa_initial, sasa_final, \"chain A\"; model=AutonBolen, cosolvent=\"TMAO\")\n\nReferences\n\nhttps://doi.org/10.1021/acs.jpcb.7b02138\nhttps://doi.org/10.1016/s0076-6879(07)28023-1\nhttps://www.pnas.org/doi/10.1073/pnas.0706251104\n\n\n\n\n\n","category":"function"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"The m-values can be estimated by the Tanford transfer model, in which each amino acid contributes to the transfer free energy according to the change in its solvent accessible surface area and  experimental values of individual amino acid transfer energies, and a backbone contribution (here we implement the Auton/Bolen and Moeser/Horinek models  [1,  2,  3]).  Typically, these models are used to obtain the effect of cosolvent on the structural stability of proteins, but the current implementation allows the practical use of these functions to compute m-values of  more general transformations, as described in the examples.","category":"page"},{"location":"mvalue/#Protein-denaturation","page":"m-values","title":"Protein denaturation","text":"","category":"section"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"Consider these two states of a model protein, a native and a denatured (straight chain) state, for which we compute the SASA:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"using PDBTools\nnative_state = read_pdb(PDBTools.src_dir*\"/tools/mvalue/1MJC_native.pdb\", \"protein\")\nsasa_native = sasa_particles(native_state)","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"desnat_state = read_pdb(PDBTools.src_dir*\"/tools/mvalue/1MJC_straight.pdb\", \"protein\")\nsasa_desnat = sasa_particles(desnat_state)","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"The denatured state has a greater surface area than the native state. Thus, cosolvents  that bind preferentially to the surface, as urea, should promote a stabilization of the denatured state. This is obtained with:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"m = mvalue(sasa_native, sasa_desnat, \"urea\"; model=MoeserHorinek)","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"Where the tot, bb and sc fields contain, respectively, the total, backbone and side-chain contributions. The MValue object contains, additionally, the contribution of the side chain and backbone of  each amino acid residue type for the m-value, in the residue_contributions_bb and residue_contributions_sc fields.","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"We can set the beta fields (for example) of the atoms as the residue contributions:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"for (ir, r) in enumerate(eachresidue(native_state)) # iterate over residues\n    # total contribution of residue ir\n    c_residue = m.residue_contributions_sc[ir] + m.residue_contributions_bb[ir]\n    for at in r # iterate over atoms in residue\n        at.beta = c_residue\n    end\nend\nwrite_pdb(\"contrib.pdb\", native_state)","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"And with that get an image (here produced with VMD) of the contributions of the residues to the transfer free energies:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"<img src=\"../assets/mvalue.png\" width=30%>","category":"page"},{"location":"mvalue/#Cofactor-binding","page":"m-values","title":"Cofactor binding","text":"","category":"section"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"The 1BSX protein-data-bank structure contains a nuclear hormone receptor bound to a cofactor:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"bsx = wget(\"1BSX\")\ncollect(eachchain(bsx))","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"Chains A and B belong to the receptor and the cofactor. Let us understand the effect of cosolvents on the association of these two chains. ","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"First, we compute the SASA of chains A and B, thus including chain A in bound to the cofactor:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"cAB = sasa_particles(select(bsx, \"chain A B\"))","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"and, then, we compute the SASA of chain A without the cofactor:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"cA_free = sasa_particles(select(bsx, \"chain A\"))","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"Note that the SASA of chain A in the bound state is smaller than that of the free state, as expected:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"sasa(cAB, \"chain A\")","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"We now compute the m-value of chain A only, but using the surface areas computed in the two different states:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"mvalue(cAB, cA_free, \"urea\"; sel=\"chain A\", model=MoeserHorinek)","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"where the tot field is negative, indicating that exposing the cofactor binding surface is slightly favorable in urea.  ","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"The same applies to the cofactor, chain B:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"cB_free = sasa_particles(select(bsx, \"chain B\"))\nmvalue(cAB, cB_free, \"urea\"; sel=\"chain B\", model=MoeserHorinek)","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"and the exposed surface of the cofactor is also slightly stabilized in urea. Urea, thus tends to destabilize the binding of the cofactor to the receptor.","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"By contrast, in a cosolvent that tends to promote protein aggregation, we have:","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"mvalue(cAB, cA_free, \"Sucrose\"; sel=\"chain A\")","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"and","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"mvalue(cAB, cB_free, \"Sucrose\"; sel=\"chain B\")","category":"page"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"and thus Sucrose can stabilize cofactor binding. We remark that the values obtained here are very small, and this is intended to be only an illustrative example.","category":"page"},{"location":"mvalue/#Alternative-SASA-calculations","page":"m-values","title":"Alternative SASA calculations","text":"","category":"section"},{"location":"mvalue/","page":"m-values","title":"m-values","text":"The following functions can be used to compute m-values from the variation of the SASA per residue  type, which allow the use of external tools to compute the SASA. This is used mostly for testing  purposes. The functions allow the use of SASAs obtained directly from the Auton & Bolen server, or  from Gromacs SASA calculations.","category":"page"},{"location":"mvalue/#PDBTools.mvalue_delta_sasa","page":"m-values","title":"PDBTools.mvalue_delta_sasa","text":"mvalue_delta_sasa(; model=MoeserHorinek, cosolvent=\"urea\", atoms:AbstractVector{<:PDBTools.Atom}, sasas, type=1)\n\nCalculates the m-value (transfer free energy of a protein in 1M solution) using the Tanford transfer model, as implemented by Moeser and Horinek [1] or by Auton and Bolen [2,3].\n\nArguments\n\nmodel: The model to be used. Must be MoeserHorinek or AutonBolen. MoeserHorinek is only implemented for cosolvent=\"urea\",  and should be more precise in that case. Other solvents are available for AutonBolen.\ncosolvent::String: One of \"betaine\", \"proline\", \"sarcosine\", \"sorbitol\", \"sucrose\", \"tmao\", \"urea\", \"urea-app\", \"urea-mh\"\natoms::AbstractVector{<:PDBTools.Atom}: Vector containing the atoms of the structure.\nsasas::Dict{String, Dict{Symbol, Float64}}: A dictionary containing the change in solvent accessible surface area (SASA) upon denaturation for each amino acid type. This data can be obtained from the m-value server or calculated using GROMACS:\nThe output of the server can be parsed using the parse_mvalue_server_sasa function defined in this module.\nCompute the SASA with delta_sasa_per_restype, a SASA calculation utility implemented in PDBTools.jl.\nSASA values can be calculated using GROMACS with the gmx_delta_sasa_per_restype function defined in this module.\ntype::Int: Specifies which SASA value to use from the provided data, because the server provides minimum, average, and maximum values,   according to different denatured models for the protein. The recommended value is 2 for comparison with experimental data.   Normally, GROMACS calculations will provide a single value, so type=1 should be used in that case.\n\nReturns\n\nA named tuple with the following fields:\n\ntot: Total transfer free energy (kcal/mol).\nbb: Contribution from the backbone (kcal/mol).\nsc: Contribution from the side chains (kcal/mol).\nrestype: A dictionary with the transfer free energy contributions per residue type (kcal/mol).\n\nEach entry in the dictionary is a named tuple with bb and sc fields representing the backbone and side chain contributions, respectively.\n\nExample calls\n\nusing PDBTools\nusing PDBTools: mvalue_delta_sasa\nusing PDBTools: delta_sasa_per_restype, parse_mvalue_server_sasa, gmx_delta_sasa_per_restype\nprotein = read_pdb(\"protein.pdb\")\n\n# Using SASA values calculated with PDBTools.jl\nsasas=delta_sasa_per_restype(native=read_pdb(\"native.pdb\"), desnat=read_pdb(\"desnat.pdb\"))\nmvalue_delta_sasa(; model=AutonBolen, cosolvent=\"TMAO\", atoms=protein, sasas=sasas)\n\n# Using SASA values from the m-value server\nsasas_from_server=parse_mvalue_server_sasa(server_output)\nmvalue_delta_sasa(; model=MoeserHorinek, cosolvent=\"urea\", atoms=protein, sasas=sasas_from_server, type=2)\n\n# Using SASA values calculated with GROMACS\nsasas_gmx=gmx_delta_sasa_per_restype(native_pdb=\"native.pdb\", desnat_pdb=\"desnat.pdb\")\nmvalue_delta_sasa(; model=AutonBolen, cosolvent=\"TMAO\", atoms=protein, sasas=sasas_gmx)\n\nReferences\n\nhttps://doi.org/10.1021/acs.jpcb.7b02138\nhttps://doi.org/10.1016/s0076-6879(07)28023-1\nhttps://www.pnas.org/doi/10.1073/pnas.0706251104\n\n\n\n\n\n","category":"function"},{"location":"mvalue/#PDBTools.delta_sasa_per_restype","page":"m-values","title":"PDBTools.delta_sasa_per_restype","text":"delta_sasa_per_restype(; \n    native::AbstractVector{<:PDBTools.Atom}, \n    desnat::AbstractVector{<:PDBTools.Atom}\n)\n\nCalculates the change in solvent accessible surface area (SASA) upon denaturation for each amino acid type using PDBTools. Returns a dictionary that can be directly used as input to the mvalue function.\n\nArguments\n\nnative: Vector of PDBTools.Atom objects for the native structure.\ndesnat: Vector of PDBTools.Atom objects for the denatured structure.\n\nReturns\n\nA dictionary where each key is an amino acid three-letter code (e.g., \"ALA\", \"PHE\"), and the value is another dictionary with two keys: :sc for side chain SASA values and :bb for backbone SASA values. Each of these keys maps to a tuple containing a single Float64 value representing the change in SASA upon denaturation in Å².\n\nOptional arguments\n\nn_dots::Int=500: Sets the precision of the SASA calculation (greater is better).\nbackbone::Function = at -> name(at) in (\"N\", \"CA\", \"C\", \"O\"): Define what is a backbone atom.\nsidechain::Function = at -> !(name(at) in (\"N\", \"CA\", \"C\", \"O\")): Define what is a sidechain atom.\nignore_hydrogen::Bool = true: By default, ignore all Hydrogen atoms of the structure.\nunitcell=nothing: By default, do not use periodic boundary conditions. To use PBCs, define A unitcell by providing either a 3x3 matrix or, for orthorhombic cells, a vector of length 3 of cell sides.\n\n\n\n\n\n","category":"function"},{"location":"mvalue/#PDBTools.parse_mvalue_server_sasa","page":"m-values","title":"PDBTools.parse_mvalue_server_sasa","text":"parse_mvalue_server_sasa(string::AbstractString)\n\nParses the SASA output from the m-value calculator server (http://best.bio.jhu.edu/mvalue/), into a dictionary that can be directly used as input to the mvalue function.\n\nThe input string should contain lines formatted as follows, and correspond to the SASA values for each amino acid type:\n\nsasa_from_server = \"\"\"\nALA \t8 \t (    11.1)     79.1 [   147.1] | (   -13.0)     51.4 [   115.8] \nPHE \t3 \t (   166.9)    197.1 [   230.2] | (    29.4)     56.4 [    83.4] \nLEU \t7 \t (   475.2)    532.2 [   589.3] | (    89.3)    145.3 [   201.3] \n...\nLYS \t6 \t (   171.5)    220.4 [   269.3] | (    -4.5)     42.0 [    88.5] \nARG \t1 \t (   110.2)    124.4 [   138.6] | (    17.1)     25.0 [    33.0] \nCYS \t0 \t (     0.0)      0.0 [     0.0] | (     0.0)      0.0 [     0.0] \n\"\"\"\n\nThis data can be found in the output of the server, under the title  \"Sidechain and Backbone changes in Accessible Surface Area\".\n\nThe function returns a dictionary where each key is an amino acid three-letter code (e.g., \"ALA\", \"PHE\"), and the value  is another dictionary with two keys: :sc for side chain SASA values and :bb for backbone SASA values.  Each of these keys maps to a tuple containing three Float64 values representing the minimum, average, and maximum SASA values in Å².\n\n\n\n\n\n","category":"function"},{"location":"mvalue/#PDBTools.gmx_delta_sasa_per_restype","page":"m-values","title":"PDBTools.gmx_delta_sasa_per_restype","text":"gmx_delta_sasa_per_restype(; native_pdb::AbstractString, desnat_pdb::AbstractString)\n\nCalculates the change in solvent accessible surface area (SASA) upon denaturation for each amino acid type using GROMACS. Returns a dictionary that can be directly used as input to the mvalue function.\n\nnote: Note\nThis function requires GROMACS (gmx sasa executable) to be installed and accessible from the command line. The path to the gmx executable can be provided with the gmx keyword.\n\nArguments\n\nnative_pdb::AbstractString: Path to the PDB file of the native protein structure.\ndesnat_pdb::AbstractString: Path to the PDB file of the denatured protein structure.\n\nOptional arguments\n\ngmx: the path to the gmx GROMACS exectuable (by default it expects gmx to be on the path).\nn_dots::Int: sets the precision of the SASA grid (greater is better).\nbackbone::Function = at -> name(at) in (\"N\", \"CA\", \"C\", \"O\"): Define what is a backbone atom.\nsidechain::Function = at -> !(name(at) in (\"N\", \"CA\", \"C\", \"O\")): Define what is a sidechain atom.\nignore_hydrogen::Bool=true: By default, ignore all hydrogen atoms.\n\nReturns\n\nA dictionary where each key is an amino acid three-letter code (e.g., \"ALA\", \"PHE\"), and the value is another dictionary with two keys: :sc for side chain SASA values and :bb for backbone SASA values. Each of these keys maps to a tuple containing a single Float64 value representing the change in SASA upon denaturation in Å².\n\n\n\n\n\n","category":"function"},{"location":"sasa/#Solvent-Accessible-Surface-Area-(SASA)","page":"Solvent Accessible Area","title":"Solvent Accessible Surface Area (SASA)","text":"","category":"section"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"These functions are used to compute the solvent accessible surface area (SASA) of structures or parts of a structure. They provide a very fast implementation of the Shake-Rupley method, using a Fibonacci lattice to construct the grid points.","category":"page"},{"location":"sasa/#PDBTools.sasa_particles","page":"Solvent Accessible Area","title":"PDBTools.sasa_particles","text":"sasa_particles(atoms; probe_radius, n_dots)\n\nCalculates the Solvent Accessible Surface Area (SASA) for a vector of Atoms. \n\nMain argument\n\natoms::Vector{PDBTools.Atom}: A vector of atoms in the molecule.\n\nReturns\n\nPDBTools.SASA structure, containing the vector of atoms, the SASA of each atom (in Å²) and, optionally, the solvent accessible dots that define the surface. \n\nThe sasa function computes the total SASA or the SASA of a subset of the atoms in the structure.\n\nOptional arguments\n\nprobe_radius::Real=1.4f0: The radius of the solvent probe in Angstroms.\nn_dots::Int=512: The number of grid points along one axis for dot generation.  Higher values lead to more accurate but slower calculations.\nunitcell=nothing: if periodic boundary conditions are used, provide a 3x3 matrix with the unitcell, or alternatively a vector of length 3 with the sides, for orthorhombic cells.\nparallel::Bool=true: Control if the computation runs in parallel (requires  running Julia with multiple threads).\n\nExample\n\njulia> using PDBTools\n\njulia> prot = select(read_pdb(PDBTools.TESTPDB), \"protein\");\n\njulia> at_sasa = sasa_particles(prot);\n\njulia> sasa(at_sasa) # total sasa of prot\n5389.0146f0\n\njulia> sasa(at_sasa, \"backbone\") # backbone sasa in prot\n988.7648f0\n\njulia> sasa(at_sasa, \"not backbone\") # other atoms\n4400.246f0\n\njulia> sasa(at_sasa, \"resname ARG GLU\") # some residue types\n543.29846f0\n\nAdditional control:\n\nTwo arguments can control the atom radii used for computing the SASA. These arguments are functions:\n\natom_type: Function that given each atom of the array of atoms, returns the atom \"type\".\natom_radius_from_type: Given the atom \"type\", returns the vdW radius of the atom. \noutput_dots::Bool=false: If true, the resulting SASA structure will contain the solvent accessible   dots per particle in the dots field.\n\nBy default, atom_type = PDBTools.element, a function that just returns the element symbol of the atom, and atom_radius_from_type obtains the vdW radius from the PDBTools.elements list given the element symbol. Here, the atomic radii of https://en.wikipedia.org/wiki/Atomicradiioftheelements(datapage) are used.  Atoms with missing radius have a NaN value, and the computation will not return meaningful values. \n\n\n\n\n\n","category":"function"},{"location":"sasa/#PDBTools.sasa","page":"Solvent Accessible Area","title":"PDBTools.sasa","text":"sasa(s::SASA)\nsasa(s::SASA{<:AbstractVector{<:PDBTools.Atom}})\nsasa(atoms::SASA{<:AbstractVector{PDBTools.Atom}}, selection::Union{Function,String})\n\nGiven the output of sasa_particles, sums up contributions of atoms to compute the SASA of the full structure, an atom, or a subset of atoms. The function can be called with only a  SASA object (in which case the full SASA is returned), or with the object and a selection, given by a function or selection string. \n\nExample\n\njulia> using PDBTools\n\njulia> prot = select(read_pdb(PDBTools.TESTPDB), \"protein\");\n\njulia> at_sasa = sasa_particles(prot);\n\njulia> sasa(at_sasa) # total sasa of prot\n5389.0146f0\n\njulia> sasa(at_sasa, \"backbone\") # selection string\n988.7648f0\n\njulia> sasa(at_sasa, at -> name(at) == \"CA\") # selection function\n44.078426f0\n\njulia> sasa(at_sasa[1]) # single atom SASA\n5.467941f0\n\n\n\n\n\n","category":"function"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"A typical run of these functions consists in providing the structure of a protein to the first function, sasa_particles, to obtain a SASA object, which contains the accessible area per atom:","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"using PDBTools\nprot = read_pdb(PDBTools.TESTPDB, \"protein\")\natom_sasa = sasa_particles(prot)","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"The atom_sasa object created above can be used to extract the total accessible area or the accessible area of any sub-surface. The sasa function provides an interface for those extractions:","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"sasa(atom_sasa) # total","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"sasa(atom_sasa, \"polar\") ","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"sasa(atom_sasa, \"backbone\")","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"sasa(atom_sasa, \"resname THR and residue < 50\") ","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"In some situations, it might be useful to visualize the surface. The dots that form the surface can be obtained by running sasa_particles with the output_dots option set to true. Here, we use fewer dots for better visualization:","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"atom_sasa = sasa_particles(prot; n_dots=100, output_dots=true) ","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"Where the atom_sasa.dots field contais the dots that are accessible to the surface for each atom. These can be plotted, for example, with:","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"using Plots\ndots = reduce(vcat, atom_sasa.dots)\nscatter(Tuple.(coor.(prot)); color=:orange, msw=0, label=\"\") # atom coordinates\nscatter!(Tuple.(dots); # surface dots\n    color=:blue, ms=1, msw=0, ma=0.5, # marker properties\n    label=\"\",\n)","category":"page"},{"location":"sasa/","page":"Solvent Accessible Area","title":"Solvent Accessible Area","text":"note: Note\nThe sasa_particles function supports periodic boundary conditions if a unit cell is provided.  See the how to read the unitcell  for further information.","category":"page"},{"location":"hydrogen_bonds/#Hydrogen-bond-analysis","page":"Hydrogen bonds","title":"Hydrogen-bond analysis","text":"","category":"section"},{"location":"hydrogen_bonds/","page":"Hydrogen bonds","title":"Hydrogen bonds","text":"This tool provides a fast and practical way to compute hydrogen bonds in structures (if the structures contain hydrogen atoms).","category":"page"},{"location":"hydrogen_bonds/#PDBTools.hydrogen_bonds","page":"Hydrogen bonds","title":"PDBTools.hydrogen_bonds","text":"hydrogen_bonds(atoms, sel, sel1 => sel2, ... ; kargs...)\n\nFunction to find hydrogen bonds in a set of atoms, or among two sets of atoms. The structure must  contain Hydrogen atoms.\n\nArguments\n\natoms: Vector of atoms, or structure component (model, chain, segment, residue) to be analyzed.\n\nand, optionally, the selections or selection pairs for which the hydrogen bonds must be computed:\n\nsel::String: Selection string, e. g. \"protein\".\nsel1 => sel2::Pair{String,String}: Pair of selection strings, e. g. \"resname ARG\" => \"resname GLU\".\n\nThe two selections of each pair, if different, must not have overlapping atoms (and error will the thrown). If no selection is provided, the hydrogen bonds of the complete structure will be computed.\n\nOptional keyword arguments\n\nunitcell::Union{Nothing,AbstractVecOrMat}=nothing: Unit cell for periodic boundary conditions.\ndonor_acceptor_distance::Real=3.5f0: Maximum distance between donor and acceptor to consider a hydrogen bond.\nangle_cutoff::Real=30: Maximum angle (in degrees) between donor-hydrogen-acceptor to consider a hydrogen bond.\nelectronegative_elements=(\"N\", \"O\", \"F\", \"S\"): Elements considered electronegative for hydrogen bonding.\nd_covalent_bond::Real=1.2f0: Maximum distance between donor and hydrogen to consider a covalent bond.\nparallel::Bool=false: Whether to use parallel computation.\n\nReturns\n\nHBonds: A data structure containing the found hydrogen bonds, where each element is  a named tuple (D, H, A, r, ang) where the fields correspond to the donor, hydrogen and acceptor atoms, the distance between donor and acceptor atoms, and the angle. \n\nExample\n\njulia> using PDBTools\n\njulia> pdb = read_pdb(PDBTools.test_dir*\"/hbonds.pdb\", \"model 1\");\n\njulia> uc = read_unitcell(PDBTools.test_dir*\"/hbonds.pdb\");\n\njulia> hbs = hydrogen_bonds(pdb, \"protein\"; unitcell=uc) # Single set of atoms: selection is optional\nOrderedCollections.OrderedDict{String, PDBTools.HBonds} with 1 entry:\n  \"protein => protein\" => HBonds(Int32[1, 1, 271, 37, 1020, 237, 56, 76, 1060, 204  …  748, 813, 828, 871, 863, 877, 96…\n\njulia> hbs[\"protein => protein\"] # Summary\nHBonds data structure with 63 hydrogen-bonds.\n    First hbond: (D-H---A) = (D = 1, H = 2, A = 286, r = 2.6871147f0, ang = 10.643958f0)\n    Last hbond: (D-H---A) = (D = 1014, H = 1017, A = 1032, r = 2.5816715f0, ang = 12.714139f0)\n    - r is the distance between Donor and Acceptor atoms (D-A)\n    - ang is the angle (degrees) between H-D and A-D.\n\njulia> hbs[\"protein => protein\"][1] # first h-bond\n(D = 1, H = 2, A = 286, r = 2.6871147f0, ang = 10.643958f0)\n\njulia> hbs = hydrogen_bonds(pdb, \"protein\", \"protein\" => \"resname SOL\"; unitcell=uc) # Multiple selections\nOrderedCollections.OrderedDict{String, PDBTools.HBonds} with 2 entries:\n  \"protein => protein\"     => HBonds(Int32[1, 1, 271, 37, 1020, 237, 56, 76, 1060, 204  …  748, 813, 828, 871, 863, 877…\n  \"protein => resname SOL\" => HBonds(Int32[1406, 1583, 1799, 2027, 789, 3503, 1169, 184, 3914, 4304  …  1224, 38768, 12…\n\njulia> hbs[\"protein => protein\"]\nHBonds data structure with 63 hydrogen-bonds.\n    First hbond: (D-H---A) = (D = 1, H = 2, A = 286, r = 2.6871147f0, ang = 10.643958f0)\n    Last hbond: (D-H---A) = (D = 1014, H = 1017, A = 1032, r = 2.5816715f0, ang = 12.714139f0)\n    - r is the distance between Donor and Acceptor atoms (D-A)\n    - ang is the angle (degrees) between H-D and A-D.\n\njulia> hbs[\"protein => resname SOL\"]\nHBonds data structure with 138 hydrogen-bonds.\n    First hbond: (D-H---A) = (D = 1406, H = 1407, A = 160, r = 2.9361732f0, ang = 6.771988f0)\n    Last hbond: (D-H---A) = (D = 41798, H = 41800, A = 395, r = 2.6894214f0, ang = 10.623453f0)\n    - r is the distance between Donor and Acceptor atoms (D-A)\n    - ang is the angle (degrees) between H-D and A-D.\n\nnote: Note\nThis function does not use topology information. It identified polar hydrogens based on distance criteria only, where d_covalent_bond is the criterion for identifying covalent bonds between donor and hydrogen atoms.\n\n\n\n\n\n","category":"function"},{"location":"dihedrals/#Dihedrals-and-Ramachandran-plots","page":"Dihedrals and Ramachandran","title":"Dihedrals and Ramachandran plots","text":"","category":"section"},{"location":"dihedrals/","page":"Dihedrals and Ramachandran","title":"Dihedrals and Ramachandran","text":"Dihedral angles can be computed with the dihedral function, and an application  of this function is the computation of Ramachandran plots. ","category":"page"},{"location":"dihedrals/#MolSimToolkitShared.dihedral","page":"Dihedrals and Ramachandran","title":"MolSimToolkitShared.dihedral","text":"dihedral(at1::Atom, at2::Atom, at3::Atom, at4::Atom)\n\nComputes the dihedral angle given four atoms of type PDBTools.Atom.\n\nExample\n\njulia> using PDBTools\n\njulia> pdb = read_pdb(PDBTools.TESTPDB);\n\njulia> C1 = pdb[11]; N2 = pdb[13]; CA2 = pdb[15]; C2 = pdb[22];\n\njulia> phi = dihedral(C1, N2, CA2, C2) \n-36.70359f0\n\n\n\n\n\n","category":"function"},{"location":"dihedrals/#PDBTools.Ramachandran","page":"Dihedrals and Ramachandran","title":"PDBTools.Ramachandran","text":"Ramachandran(prot::AbstractVector{<:PDBTools.Atom})\nRamachandran # type\n\nThe Ramachandran function receives a vector of atoms of a protein and and returns a Ramachandran object, with two fields phi and psi, containing the lists of corresponding angles, that is:\n\nphi: C(-1) - N - CA - C\npsi: N - CA - C - N(+1)\n\nIf any of the above atoms is missing, the function errors. The residues are expected to belong to a single chain and consecutive. \n\nThe resulting Ramachandran object can be plotted with the Plots.scatter function.\n\nExample\n\njulia> using PDBTools\n\njulia> prot = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> ram = Ramachandran(prot)\nRamachandran data: phi, psi vectors with 102 angles.\n\n\n\n\n\n\n","category":"type"},{"location":"dihedrals/#Plots.scatter-Tuple{Ramachandran}","page":"Dihedrals and Ramachandran","title":"Plots.scatter","text":"scatter(ram::Ramachandran; kargs...)\n\nCreates a Ramachandran plot given a Ramachandran object.\n\nArguments\n\nram::Ramachandran: the Ramachandran object, containing ϕ and ψ angles,  resulting from the the Ramachandan function.\n\nAll other arguments are default keywords of Plots.scatter and can be adjusted to customize the plot.\n\nExample\n\njulia> using PDBTools, Plots\n\njulia> prot = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> ram = Ramachandran(prot)\nRamachandran data: phi, psi vectors with 102 angles.\n\njulia> # plt = scatter(map) # uncomment to plot\n\n\n\n\n\n","category":"method"},{"location":"dihedrals/#Dihedral-angles","page":"Dihedrals and Ramachandran","title":"Dihedral angles","text":"","category":"section"},{"location":"dihedrals/","page":"Dihedrals and Ramachandran","title":"Dihedrals and Ramachandran","text":"The dihedral function computes the dihedral angle given four atoms:","category":"page"},{"location":"dihedrals/","page":"Dihedrals and Ramachandran","title":"Dihedrals and Ramachandran","text":"julia> using PDBTools\n\njulia> prot = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> dihedral(prot[1], prot[5], prot[11], prot[13])\n64.07296f0","category":"page"},{"location":"dihedrals/#Ramachandran-plot","page":"Dihedrals and Ramachandran","title":"Ramachandran plot","text":"","category":"section"},{"location":"dihedrals/","page":"Dihedrals and Ramachandran","title":"Dihedrals and Ramachandran","text":"The Ramachandran function and object are used to compute and plot Ramachandran plots for a protein structure. The call to Ramachandran(vec) where vec is a vector of Atoms returns a Ramachandran object, with fields phi and psi, containing the list of dihedral angles:","category":"page"},{"location":"dihedrals/","page":"Dihedrals and Ramachandran","title":"Dihedrals and Ramachandran","text":"using PDBTools\nprot = read_pdb(PDBTools.TESTPDB, \"protein\");\nram = Ramachandran(prot)","category":"page"},{"location":"dihedrals/","page":"Dihedrals and Ramachandran","title":"Dihedrals and Ramachandran","text":"Given the ram::Ramachandran object, the scatter function from Plots can be used to  produce the Ramachandran plot:","category":"page"},{"location":"dihedrals/","page":"Dihedrals and Ramachandran","title":"Dihedrals and Ramachandran","text":"using Plots\nscatter(ram)","category":"page"},{"location":"dihedrals/","page":"Dihedrals and Ramachandran","title":"Dihedrals and Ramachandran","text":"All scatter parameters can be customized using the Plots keyword syntax. ","category":"page"},{"location":"auxiliary/#Some-auxiliary-functions-to-quickly-retrieve-some-data","page":"Auxiliary functions","title":"Some auxiliary functions to quickly retrieve some data","text":"","category":"section"},{"location":"auxiliary/#Get-the-protein-sequence","page":"Auxiliary functions","title":"Get the protein sequence","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"To obtain a list of the residue names of the protein with three- and one-letter codes, use","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> pdb = read_pdb(PDBTools.SMALLPDB);\n\njulia> getseq(pdb)\n3-element Vector{String}:\n \"A\"\n \"C\"\n \"D\"","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Use getseq(atoms,code=2) to get the sequence as three-letter residue codes, or code=3 to get  full natural-aminoacid names, like \"Alanine\", \"Proline\", etc:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> pdb = read_pdb(PDBTools.SMALLPDB);\n\njulia> getseq(pdb; code=2)\n3-element Vector{String}:\n \"ALA\"\n \"CYS\"\n \"ASP\"\n\njulia> getseq(pdb; code=3)\n3-element Vector{String}:\n \"Alanine\"\n \"Cysteine\"\n \"Aspartic acid\"","category":"page"},{"location":"auxiliary/#PDBTools.getseq","page":"Auxiliary functions","title":"PDBTools.getseq","text":"getseq(AbstractVector{<:Atom} or filename; selection, code)\n\nReturns the sequence of amino acids from the vector of atoms or file name. Selections may be applied. Code defines if the output will be a one-letter, three-letter or full-residue name array.\n\nExample\n\njulia> using PDBTools\n\njulia> protein = read_pdb(PDBTools.TESTPDB);\n\njulia> getseq(protein, \"residue < 3\")\n2-element Vector{String}:\n \"A\"\n \"C\"\n\njulia> getseq(protein, \"residue < 3\"; code=2)\n2-element Vector{String}:\n \"ALA\"\n \"CYS\"\n\njulia> getseq(protein, \"residue < 3\"; code=3)\n2-element Vector{String}:\n \"Alanine\"\n \"Cysteine\"\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#PDBTools.Sequence","page":"Auxiliary functions","title":"PDBTools.Sequence","text":"Sequence\n\nWrapper for strings, or vectors of chars, strings, or residue names, to dispatch on  functions that operate on amino acid sequences.\n\nExample\n\njulia> seq = [\"Alanine\", \"Glutamic acid\", \"Glycine\"];\n\njulia> mass(Sequence(seq))\n257.2432\n\njulia> seq = \"AEG\";\n\njulia> mass(Sequence(seq))\n257.2432\n\n\n\n\n\n","category":"type"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"note: Note\nIf there is some non-standard protein residue in the sequence, inform the getseq function by adding a selection:julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> for at in atoms\n          if resname(at) == \"ALA\"\n              at.resname = \"NEW\"\n          end\n       end\n\njulia> getseq(atoms, \"protein or resname NEW\"; code=2)\n3-element Vector{String}:\n \"NEW\"\n \"CYS\"\n \"ASP\"By default the selection will only return the sequence of natural amino acids. ","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The getseq function can of course be used on an Atom list, accepts selections as the last argument, as well as the reading and writing functions:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> getseq(atoms, \"residue > 1\")\n2-element Vector{String}:\n \"C\"\n \"D\"","category":"page"},{"location":"auxiliary/#Distance-between-sets-of-atoms","page":"Auxiliary functions","title":"Distance between sets of atoms","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The distance between atoms, or sets of atoms, can be computed with the distance function. This function returns the minimum distance between the atoms of the sets involved. For example:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> model = wget(\"1BSX\");\n\njulia> protein = select(model,\"protein\");\n\njulia> ligand = select(model,\"resname T3\");\n\njulia> distance(protein,ligand)\n2.7775834820937417","category":"page"},{"location":"auxiliary/#PDBTools.distance","page":"Auxiliary functions","title":"PDBTools.distance","text":"distance(x,y)\n\nComputes the minimum distance between two sets of atoms, between an atom and a set of atoms, or simply  the distance between two atoms, or from the coordinates or sets of coordinates. \n\nThe input may be an Atom vector of Atoms, or a 3D vector, or a vector of 3D vector of coordinates, for examples as output by the coor function.\n\nExamples\n\njulia> model = wget(\"1BSX\");\n\njulia> protein = select(model,\"protein\");\n\njulia> ligand = select(model,\"resname T3\");\n\njulia> distance(protein,ligand)\n2.7775834820937417\n\njulia> distance(protein[1],ligand[3])\n36.453551075306784\n\njulia> distance(coor(ligand),protein)\n2.7775834820937417\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Closest-atoms-and-their-distance","page":"Auxiliary functions","title":"Closest atoms and their distance","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"A function similar to the one above is closest, which returns the shortest distance between atoms but also the identity of the atom or pair of atoms that satisfy that shortest distance:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> model = wget(\"1BSX\");\n\njulia> protein = select(model,\"protein\");\n\njulia> ligand = select(model,\"resname T3\");\n\njulia> closest(ligand,protein)\n(43, 3684, 2.7775834820937417)\n\njulia> ligand[43]\n    4037   O1      T3     B        2      512  -22.568   81.625    3.159  1.00 36.59     1       -      4041\n\njulia> protein[3684]\n    3684  NE2     HIS     B      435      472  -21.539   82.145    5.686  1.00 44.44     1       -      3686\n\njulia> distance(ligand[43],protein[3684])\n2.7775834820937417","category":"page"},{"location":"auxiliary/#PDBTools.closest","page":"Auxiliary functions","title":"PDBTools.closest","text":"closest(x,y)\n\nComputes the minimum distance between two sets of atoms and returns the indices of the atoms  and their distance. Both vector of atoms or vectors of coordinates can be used as input.\n\nExamples\n\njulia> model = wget(\"1BSX\");\n\njulia> protein = select(model,\"protein\");\n\njulia> ligand = select(model,\"resname T3\");\n\njulia> closest(ligand,protein)\n(43, 3684, 2.7775834820937417)\n\njulia> ligand[43]\n    4037   O1      T3     B        2      512  -22.568   81.625    3.159 36.59  1.00     1       -      4041\n\njulia> closest(ligand[43],protein)\n(1, 3684, 2.7775834820937417)\n\njulia> x = coor(protein)\n3994-element Vector{SVector{3, Float64}}:\n [52.884, 24.022, 35.587]\n [52.916, 24.598, 36.993]\n ⋮\n [-46.887, 86.925, 13.235]\n [-47.164, 83.593, 15.25]\n\njulia> closest(ligand,x)\n(43, 3684, 2.7775834820937417)\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Obtain-arrays-with-coordinates","page":"Auxiliary functions","title":"Obtain arrays with coordinates","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Use the coor function:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> coor(atoms[1])\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n  -9.229\n -14.861\n  -5.481\n\njulia> coor(atoms[1:2])\n2-element Vector{StaticArraysCore.SVector{3, Float32}}:\n [-9.229, -14.861, -5.481]\n [-10.048, -15.427, -5.569]","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The coor function accepts selections:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Calpha coordinates:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> coor(atoms, \"name CA\")\n3-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-8.483, -14.912, -6.726]\n [-5.113, -13.737, -5.466]\n [-3.903, -11.262, -8.062]","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The coordinates are output as arrays of static arrays (more specifically, as a Vector{SVector{3,Float64}}, from StaticArrays). ","category":"page"},{"location":"auxiliary/#PDBTools.coor","page":"Auxiliary functions","title":"PDBTools.coor","text":"coor(atoms; selection)\n\nReturns the coordinates of the atoms. The input may be one atom (type Atom), a vector of atoms, or a Residue.  The coordinates are returned as a vector of static vectors (from StaticArrays), more specifically as a Vector{SVector{3,Float64}}.\n\nExamples\n\njulia> using PDBTools, StaticArrays \n\njulia> protein = wget(\"1LBD\");\n\njulia> coor(protein[1])\n3-element SVector{3, Float64} with indices SOneTo(3):\n 45.228\n 84.358\n 70.638\n\njulia> coor(protein[1],as=SVector{3,Float32})\n3-element SVector{3, Float32} with indices SOneTo(3):\n 45.228\n 84.358\n 70.638\n\njulia> coor(protein, \"index <= 2\")\n2-element Vector{SVector{3, Float64}}:\n [45.228, 84.358, 70.638]\n [46.08, 83.165, 70.327]\n\njulia> coor(protein, at -> at.resname == \"ALA\")\n110-element Vector{SVector{3, Float64}}:\n [43.94, 81.982, 70.474]\n [43.02, 80.825, 70.455]\n [41.996, 80.878, 69.34]\n ⋮\n [-17.866, 84.088, 51.741]\n [-18.496, 83.942, 52.777]\n [-15.888, 82.583, 51.706]\n  \njulia> residues = collect(eachresidue(protein));\n\njulia> coor(residues[1])\n6-element Vector{SVector{3, Float64}}:\n [45.228, 84.358, 70.638]\n [46.08, 83.165, 70.327]\n [45.257, 81.872, 70.236]\n [45.823, 80.796, 69.974]\n [47.147, 82.98, 71.413]\n [46.541, 82.639, 72.662]\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#read-unitcell","page":"Auxiliary functions","title":"Read and convert unit cells","text":"","category":"section"},{"location":"auxiliary/#PDBTools.read_unitcell","page":"Auxiliary functions","title":"PDBTools.read_unitcell","text":"read_unitcell(file::AbstractString)\n\nReads the lattice parameters of unitcell from a PDB (CRYST1 field) or mmCIF file, and converts it to a unitcell matrix with the lattice_to_matrix function. The unitcell matrix contains the lattice vectors as the columns of the matrix. \n\nExample\n\njulia> using PDBTools\n\njulia> m = read_unitcell(PDBTools.TESTPBC)\n3×3 StaticArraysCore.SMatrix{3, 3, Float32, 9} with indices SOneTo(3)×SOneTo(3):\n 85.0  -3.71547f-6  -3.71547f-6\n  0.0  85.0         -3.71547f-6\n  0.0   0.0         85.\n\njulia> matrix_to_lattice(m)\n(a = 85.0f0, b = 85.0f0, c = 85.0f0, α = 90.0f0, β = 90.0f0, γ = 90.0f0)\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#PDBTools.lattice_to_matrix","page":"Auxiliary functions","title":"PDBTools.lattice_to_matrix","text":"lattice_to_matrix(a, b, c, α, β, γ)\n\nConverts unit cell lattice parameters and convert them to a 3x3 unit cell matrix (orthogonalization matrix), where the lattice vectors are the columns of the matrix.\n\nThe resulting matrix has the lattice vectors as its columns, with vector 'a' aligned along the x-axis and vector 'b' in the xy-plane. This matrix can be used to transform fractional coordinates to Cartesian coordinates.\n\nArguments\n\na::Real: Length of side a in Ångströms.\nb::Real: Length of side b in Ångströms.\nc::Real: Length of side c in Ångströms.\nα::Real: Angle alpha in degrees.\nβ::Real: Angle beta in degrees.\nγ::Real: Angle gamma in degrees.\n\nReturns\n\nA 3x3 static matrix representing the unit cell vectors.\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#PDBTools.matrix_to_lattice","page":"Auxiliary functions","title":"PDBTools.matrix_to_lattice","text":"matrix_to_lattice(M::AbstractMatrix)\n\nConverts a 3x3 unit cell matrix where the lattice vectors are the columns, back into the six  lattice parameters (sides a, b, c and angles α, β, γ).\n\nArguments\n\nM::AbstractMatrix: A 3x3 matrix where columns are the lattice vectors.\n\nReturns\n\nNamedTuple: A named tuple containing the six parameters: (a, b, c, α, β, γ). Lengths are in the matrix's original units (typically Ångströms), and angles are in degrees.\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Check-the-stereochemistry-of-protein-residues","page":"Auxiliary functions","title":"Check the stereochemistry of protein residues","text":"","category":"section"},{"location":"auxiliary/#PDBTools.zeta","page":"Auxiliary functions","title":"PDBTools.zeta","text":"zeta(r::Residue)\n\nComputes the Cα chirality (zeta \"virtual\" torsion angle - Cα-N-C-Cβ).\n\nReturns the torsion angle or NaN if the residue is not recognized a protein residue or if its a Gly residue. Expected values are 33.9 ± 3.5 degrees (for one standard deviation). Also see the zeta_check function.\n\nExample\n\njulia> using PDBTools\n\njulia> protein = select(read_pdb(PDBTools.TESTPDB), \"protein\");\n\njulia> residues = collect(eachresidue(protein));\n\njulia> zeta(residues[1])\n33.67202f0\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#PDBTools.zeta_check","page":"Auxiliary functions","title":"PDBTools.zeta_check","text":"zeta_check(r::Residue; nsigma=2)\n\nChecks if the Cα chirality falls into expected ranges. See the zeta function for further information. The expected mean is 33.9 degrees with a standard deviation of 3.5 degrees. By default, nsigma=2, implying that the function returns true if the torsion falls  within two standard deviations from the mean.\n\nSee: https://www.ebi.ac.uk/thornton-srv/software/PROCHECK/manual/manappa.html\n\nExample\n\njulia> using PDBTools\n\njulia> protein = select(read_pdb(PDBTools.TESTPDB), \"protein\");\n\njulia> residues = collect(eachresidue(protein));\n\njulia> zeta_check(residues[1])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Maximum-and-minimum-coordinates-of-the-atoms","page":"Auxiliary functions","title":"Maximum and minimum coordinates of the atoms","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Use maxmin(atoms), or maxmin(atoms,\"resname CA\"), for example:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> maxmin(atoms, \"residue > 1\")\n Minimum atom coordinates: xmin = [-6.974, -16.785, -10.863]\n Maximum atom coordinates: xmax = [-1.94, -9.552, -3.844]\n Length in each direction: xlength = [5.034000000000001, 7.2330000000000005, 7.019]","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"m is a structure containing the three vectors with minimum and maximum coordinates, and lengths.","category":"page"},{"location":"auxiliary/#PDBTools.maxmin","page":"Auxiliary functions","title":"PDBTools.maxmin","text":"maxmin(atoms::AbstractVector{<:Atom}; selection)\n\nReturns the maximum and minimum coordinates of an atom vector, and the length (maximum minus minimum) in each direction. \n\nExample\n\njulia> protein = wget(\"1LBD\");\n\njulia> maxmin(protein)\n \n Minimum atom coordinates: xmin = [-29.301, 57.178, 45.668]\n Maximum atom coordinates: xmax = [47.147, 99.383, 86.886]\n Length in each direction: xlength = [76.448, 42.205, 41.217999999999996]\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Residue-tick-labels-for-plots","page":"Auxiliary functions","title":"Residue tick labels for plots","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The residue_ticks function provides a practical way to define tick labels in plots associated to an amino-acid sequence:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"residue_ticks(\n    atoms (or) residues (or) residue iterator; \n    first=nothing, last=nothing, stride=1, oneletter=true, serial=false,\n)","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The input structure can be provided as a vector of atoms (type Vector{<:Atom}) a residue iterator (obtained by eachresidue(atoms)) or a vector of residues (obtained by collect(eachresidue(atoms))). ","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The function returns a tuple with residue numbers and residue names for the given atoms, to be used as tick labels in plots.","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"first and last optional keyword parameters are integers that refer to the residue numbers to be included.  The stride option can be used to skip residues and declutter the tick labels.","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"If oneletter is false, three-letter residue codes are returned. Residues with unknown names will be  named X or XXX. ","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"if serial=false the positions of the ticks will be returned as a the serial residue index in the structure. If serial=true the positions of the ticks are returned as their residue numbers. This difference is important if the residue numbers do not start at 1 and depending on the indexing of the data to be plotted.  ","category":"page"},{"location":"auxiliary/#PDBTools.residue_ticks","page":"Auxiliary functions","title":"PDBTools.residue_ticks","text":"residue_ticks(\n    atoms (or) residues (or) residue iterator; \n    first=nothing, last=nothing, stride=1, oneletter=true, serial=false\n)\n\nReturns a tuple with residue numbers and residue names for the given atoms, to be used as tick labels in plots.\n\nThe structure data can be provided a vector of Atoms, a vector of Residues or an eachresidue iterator. \n\nfirst and last optional keyword parameters are integers that refer to the residue numbers to be included.  The stride option can be used to skip residues and declutter the tick labels.\n\nIf oneletter is false, three-letter residue codes are returned. Residues with unknown names will be  named X or XXX. \n\nIf serial=true the sequential residue index will be used as the index of the ticks. If instead serial=false, the positions will be set to the residue numbers.\n\nExamples\n\njulia> using PDBTools\n\njulia> atoms = wget(\"1LBD\", \"protein\");\n\njulia> residue_ticks(atoms; stride=50) # Vector{<:Atom} as input\n(Int32[225, 275, 325, 375, 425], [\"S225\", \"Q275\", \"L325\", \"L375\", \"L425\"])\n\njulia> residue_ticks(atoms; first=235, last=240) # first=10\n(Int32[235, 236, 237, 238, 239, 240], [\"I235\", \"L236\", \"E237\", \"A238\", \"E239\", \"L240\"])\n\njulia> residue_ticks(eachresidue(atoms); stride=50) # residue iterator as input\n(Int32[225, 275, 325, 375, 425], [\"S225\", \"Q275\", \"L325\", \"L375\", \"L425\"])\n\njulia> residue_ticks(collect(eachresidue(atoms)); stride=50) # Vector{Residue} as input\n(Int32[225, 275, 325, 375, 425], [\"S225\", \"Q275\", \"L325\", \"L375\", \"L425\"])\n\njulia> residue_ticks(atoms; first=10, stride=50, serial=true) # using serial=true\n(10:50:210, [\"R234\", \"K284\", \"R334\", \"S384\", \"E434\"])\n\n\nThe resulting tuple of residue numbers and labels can be used as xticks in Plots.plot, for example.\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#PDBTools.oneletter","page":"Auxiliary functions","title":"PDBTools.oneletter","text":"oneletter(residue::Union{AbstractString,Char})\n\nFunction to return a one-letter residue code from the three letter code or residue name. The function is case-insensitive.\n\nExamples\n\njulia> oneletter(\"ALA\")\n\"A\"\n\njulia> oneletter(\"Glutamic acid\")\n\"E\"\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#PDBTools.threeletter","page":"Auxiliary functions","title":"PDBTools.threeletter","text":"threeletter(residue::String)\n\nFunction to return the three-letter natural-amino acid residue code from the one-letter  code or residue name. The function is case-insensitive.\n\nExamples\n\njulia> threeletter(\"A\")\n\"ALA\"\n\njulia> threeletter(\"Aspartic acid\")\n\"ASP\"\n\njulia> threeletter(\"HSD\")\n\"HIS\"\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Example","page":"Auxiliary functions","title":"Example","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Here we illustrate how to plot the average temperature factor of each residue of a crystallographic model as function of the residues.","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools, Plots\n\njulia> atoms = wget(\"1UBQ\", \"protein\");\n\njulia> residue_ticks(atoms; stride=10) # example of output\n([1, 11, 21, 31, 41, 51, 61, 71], [\"M1\", \"K11\", \"D21\", \"Q31\", \"Q41\", \"E51\", \"I61\", \"L71\"])\n\njulia> plot(\n           resnum.(eachresidue(atoms)), # x-axis: residue numbers\n           [ mean(beta.(res)) for res in eachresidue(atoms) ], # y-axis: average b-factor per residue\n           xlabel=\"Residue\", \n           xticks=residue_ticks(atoms; stride=10), # here we define the x-tick labels\n           ylabel=\"b-factor\", \n           xrotation=60,\n           label=nothing, framestyle=:box,\n      )","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Produces the following plot:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"(Image: ./assets/residue_ticks.png)","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Alternatively (and sometimes conveniently), the residue ticks can be obtained by providing,  instead of the atoms array, the residue iterator or the residue vector, as:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> residue_ticks(eachresidue(atoms); stride=10)\n([1, 11, 21, 31, 41, 51, 61, 71], [\"M1\", \"K11\", \"D21\", \"Q31\", \"Q41\", \"E51\", \"I61\", \"L71\"])\n\njulia> residue_ticks(collect(eachresidue(atoms)); stride=10)\n([1, 11, 21, 31, 41, 51, 61, 71], [\"M1\", \"K11\", \"D21\", \"Q31\", \"Q41\", \"E51\", \"I61\", \"L71\"])","category":"page"},{"location":"contacts/#Contact-and-distance-maps","page":"Contact maps","title":"Contact and distance maps","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"The contact_map function computes a contact map for a structure or a pair of structures. These structures are typically proteins, but any structures defined by sequences of residues can be provided as inputs. The heatmap function, from Plots, is overloaded here to provide a convenient way to plot the contact or distance maps.","category":"page"},{"location":"contacts/#PDBTools.contact_map","page":"Contact maps","title":"PDBTools.contact_map","text":"contact_map(\n    atoms1::AbstractVector{<:PDBTools.Atom}\n    atoms2::AbstractVector{<:PDBTools.Atom}; # optional for contacts between two structures\n    dmax::Real=4.0,\n    gap::Int=0, # only available if atoms2 is not provided\n    unitcell=nothing,\n    discrete::Bool=true,\n    positions::Union{Nothing,AbstractVector{<:AbstractVector{<:Real}}}=nothing,\n)\n\nCalculate the contact map between residues in a protein* structure (if only  atoms1 is provided) or between residues in two different protein* structures (atoms1 and atoms2). \n\nnote: Note\nThe distance used to define a contact is the minimum distance between any two atoms of the residues of the atoms groups provided, with a  threshold distance dmax.\n\nReturns the contact map as a ContactMap object.\n\n*The term \"protein\" is used here to refer to any structure with residues.\n\nArguments\n\natoms1::AbstractVector{<:PDBTools.Atom}: Atoms of the first structure.\natoms2::AbstractVector{<:PDBTools.Atom}: Atoms of the second structure, if provided. \n\nOptional keyword arguments\n\ndmax::Real=4.0: Threshold distance for a contact.\ngap::Int=0: Gap between residues to calculate contacts.\nunitcell=nothing: Unit cell dimensions for periodic boundary conditions.\ndiscrete::Bool=true: If true, the matrix contains Bool values, where true  indicates a contact and false indicates no contact.  If false, the matrix contains distances between residues.\npositions: Positions of the atoms in the structure. If provided, the function uses these  positions to calculate the distance between residues.\n\nExamples\n\nContact map between residues in the same structure\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> cA = select(ats, \"chain A\");\n\njulia> cB = select(ats, \"chain B\");\n\njulia> map = contact_map(cA, cB) # contact map between chains A and B\nContactMap{Union{Missing, Bool}} of size (243, 12), with threshold 4.0 and gap 0 \n\njulia> # using Plots; heatmap(map); # uncomment to plot the contact map\n\nContact map between residues in two different structures\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> cA = select(ats, \"chain A\");\n\njulia> cB = select(ats, \"chain B\");\n\njulia> map = contact_map(cA, cB) # contact map between chains A and B\nContactMap{Union{Missing, Bool}} of size (243, 12), with threshold 4.0 and gap 0 \n\njulia> # using Plots; heatmap(map); # uncomment plot the contact map\n\n\n\n\n\n","category":"function"},{"location":"contacts/#Plots.heatmap-Tuple{ContactMap}","page":"Contact maps","title":"Plots.heatmap","text":"heatmap(map::PDBTools.ContactMap; kwargs...)\n\nPlot a contact map.\n\nArguments\n\nmap::ContactMap: the contact map to plot\n\nAll other arguments are default keywords of Plots.heatmap and can be adjusted to customize the plot.\n\nMost typical options to adjust are:\n\nxstep: the stride of the x-axis ticks \nystep: the stride of the y-axis ticks\ncolor: the color palette to use (default: :grayC for distances, :Greys_9 for binary maps)\nclims: the range of the color scale.\ncolorbar_title: the title of the colorbar. Default: \"distance (Å)\" for distances, no title for binary maps.\n\nExample\n\njulia> using PDBTools, Plots\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> cA = select(ats, \"chain A\");\n\njulia> cB = select(ats, \"chain B\");\n\njulia> map = contact_map(cA, cB)\nContactMap{Union{Missing, Bool}} of size (243, 12), with threshold 4.0 and gap 0\n\njulia> # plt = heatmap(map) # uncomment to plot\n\njulia> map = contact_map(cA, cB; discrete=false) # distance map\nContactMap{Union{Missing, Float32}} of size (243, 12), with threshold 4.0 and gap 0\n\njulia> # plt = heatmap(map) # uncomment to plot\n\n\n\n\n\n","category":"method"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"note: Note\nThe distance computed in these functions is the minimum distance between the  atoms of the residues. If, for example, a contact map computed from the distance between Cα atoms is desired, select the atoms before computing the map:cA = select(\"chain A and name CA\")\ncontact_map(cA; dmax=8.0)Importantly, the maximum distance defining a contact has to be adjusted, as it is, by default, dmax=4.0, which is a reasonable contact measure from minimum distance between atoms, but too short for distances between backbone atoms.","category":"page"},{"location":"contacts/#Contact-map","page":"Contact maps","title":"Contact map","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"A typical usage consists in computing the contact map and plotting it:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"using PDBTools\nusing Plots\nats = read_pdb(PDBTools.DIMERPDB);\ncA = select(ats, \"chain A\");\ncB = select(ats, \"chain B\");\nmap = contact_map(cA, cB) # contact map between chains A and B\nheatmap(map)","category":"page"},{"location":"contacts/#Distance-map","page":"Contact maps","title":"Distance map","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"In the example above we opted to plot a discrete contact map, with the default contact  distance dmax=4.0. Now we change two parameters: discrete=false and dmax=12.0, to compute a distance map up to a greater distance:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"using PDBTools\nusing Plots\nats = read_pdb(PDBTools.DIMERPDB);\ncA = select(ats, \"chain A\");\ncB = select(ats, \"chain B\");\nmap = contact_map(cA, cB; discrete=false, dmax=12.0) # contact map between chains A and B\nheatmap(map)","category":"page"},{"location":"contacts/#Single-structure","page":"Contact maps","title":"Single structure","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"Similarly, we can produce plots for the contact map of a single structure. Here, we  showcase the use of the gap parameter, to ignore residues closer in the sequence by less than 4 residues:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"using PDBTools\nusing Plots\nats = read_pdb(PDBTools.DIMERPDB);\ncA = select(ats, \"chain A\");\ndistance_map = contact_map(cA; gap=4, discrete=false, dmax=12.0) # chain A only\ndiscrete_map = contact_map(cA; gap=4, discrete=true, dmax=12.0) # chain A only\nplot(\n    heatmap(distance_map; colorbar=nothing, color=:davos), \n    heatmap(discrete_map); \n    layout=(1,2), size=(800,500)\n)","category":"page"},{"location":"contacts/#Customizing-the-plot","page":"Contact maps","title":"Customizing the plot","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"All heatmap parametes can be customized using the Plots keyword syntax. Above,  we illustrated this by removing the color bar and changing the color scale. ","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"Common customization options are:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"xstep: the stride of the x-axis ticks \nystep: the stride of the y-axis ticks\ncolor: the color palette to use (default: :grayC for distances, :Greys_9 for binary maps)\nclims: the range of the color scale.\ncolorbar_title: the title of the colorbar. Default: \"distance (Å)\" for distances, no title for binary maps.","category":"page"},{"location":"contacts/#Indexing","page":"Contact maps","title":"Indexing","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"The ContactMap data structure can be indexed to extract the contacts of a specific  residue. For example:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"using PDBTools\nats = read_pdb(PDBTools.DIMERPDB);\ncA = select(ats, \"chain A\");\ncB = select(ats, \"chain B\");\nmap = contact_map(cA, cB; discrete=false, dmax=12.0)\nmap[235,:] # all distances below 12.0 Angs of residue 235 of cA with cB","category":"page"},{"location":"contacts/#Data-structure-and-auxiliary-functions","page":"Contact maps","title":"Data structure and auxiliary functions","text":"","category":"section"},{"location":"contacts/#PDBTools.ContactMap","page":"Contact maps","title":"PDBTools.ContactMap","text":"ContactMap{Bool|Real}\n\nData structure to store contact maps between residues in a protein structure. The contact map is a matrix of distances between residues. A contact is defined  when the distance between any two atoms of the residues is less than a given threshold dmax.\n\nIf the distance between two residues is greater than dmax, the value in the matrix is missing, indicating that there is no contact between the residues. If the distance is less than dmax, the value in the matrix is the distance between the residues.\n\nThe gap parameter is used to calculate contacts between residues separated by a given number of residues. For example, if gap=3, the contact map was  calculated between residues separated by at least 3 residues in the sequence.\n\nFields\n\nmatrix::Matrix{Union{Missing,T}}: Matrix of distances between residues.\nd::T: Threshold distance for a contact.\ngap::Int: Gap between residues to calculate contacts.\n\nIf the contact map was calculated with discrete=true, the matrix contains Bool values, where true indicates a contact and false indicates no contact. On the other hand, if discrete=false, the matrix contains distances between residues.\n\n\n\n\n\n","category":"type"},{"location":"contacts/#PDBTools.residue_residue_distance","page":"Contact maps","title":"PDBTools.residue_residue_distance","text":"residue_residue_distance(\n    r1::PDBTools.Residue, \n    r2::PDBTools.Residue; \n    positions::AbstractVector{AbstractVector{T}}=nothing; \n    unitcell=nothing\n)\n\nCalculate the minimum distance between two residues in a protein structure.  If the positions argument is not provided, the function calculates the distance using the coordinates of the atoms in the residues. If positions is provided, the function uses the coordinates in the positions array. \n\nArguments\n\nr1::PDBTools.Residue: Residue 1\nr2::PDBTools.Residue: Residue 2\npositions::AbstractVector{AbstractVector{T}}: Optional alternate positions of the atoms in the structure.\nunitcell=nothing: Optional unit cell dimensions for periodic boundary conditions.\n\nnote: Note\nThe index of the atoms in the residues must match the index of the atoms in the positions array. \n\nExample\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> residues = collect(eachresidue(ats));\n\njulia> r1 = residues[1]; r10 = residues[10];\n\njulia> println(name(r1), resnum(r1), \" and \", name(r10), resnum(r10))\nLYS211 and GLU220\n\njulia> d = residue_residue_distance(r1, r10)\n16.16511f0\n\n\n\n\n\n","category":"function"},{"location":"selections/#selections","page":"Selections","title":"Selection functions","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"The select function can be used to select subsets of atoms from a vector of atoms. A simple selection syntax can be used, for example: ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"atoms = select(atoms, \"protein and resnum < 30\")","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"or standard Julia function can be provided as the second argument:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"atoms = select(atoms, at -> isprotein(at) && resnum(at) < 30)","category":"page"},{"location":"selections/#PDBTools.select","page":"Selections","title":"PDBTools.select","text":"select(atoms::AbstractVector{<:Atom}, selection_string::String)\nselect(atoms::AbstractVector{<:Atom}, selection_function::Function)\n\nSelects atoms from a vector of atoms using a string query, or a function.\n\nThe string query can be a simple selection like \"name CA\" or a more complex one like \"name CA or (residue 1 2 3)\". The function can be any function that takes an atom and returns a boolean value.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> select(atoms, \"name CA and (residue > 1 and residue < 3)\")\n   Vector{Atom{Nothing}} with 1 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n      15   CA     CYS     A        2        2   -5.113  -13.737   -5.466  1.00  0.00     1    PROT        15\n\njulia> select(atoms, at -> name(at) == \"CA\" && 1 < residue(at) < 3)\n   Vector{Atom{Nothing}} with 1 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n      15   CA     CYS     A        2        2   -5.113  -13.737   -5.466  1.00  0.00     1    PROT        15  \n\n\n\n\n\n\n","category":"function"},{"location":"selections/#PDBTools.Select","page":"Selections","title":"PDBTools.Select","text":"Select\n\nThis structure acts a function when used within typical julia filtering functions,  by converting a string selection into a call to query call. \n\nExample\n\nUsing a string to select the CA atoms of the first residue:\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> findfirst(Select(\"name CA\"), atoms)\n5\n\njulia> filter(Select(\"name CA and residue 1\"), atoms)\n   Vector{Atom{Nothing}} with 1 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       5   CA     ALA     A        1        1   -8.483  -14.912   -6.726  1.00  0.00     1    PROT         5\n\n\n\n\n\n\n","category":"type"},{"location":"selections/#General-selection-syntax","page":"Selections","title":"General selection syntax","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"Accepted Boolean operators: and, or, and not. \nAccepted comparison operators: <, >, <=, =>, ==\nSupport for parenthesis. \nSupport for multiple keys as a shorcut for multiple or (i. e. residue 1 3 5)","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"compat: Compat\nSupport for selection strings supporting parenthesis and multiple keys was introduced in v3.1.0\nSupport for selection by coordinates, x, y, and z was introduced in v3.2.0","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The accepted keywords for the selection are: ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Keyword Options Input value Example\nindex =,>,<,<=,>= Integer index <= 10\nindex_pdb =,>,<,<=,>= Integer index_pdb <= 10\nname  String name CA\nelement  String element N\nresname  String resname ALA\nresnum =,>,<,<=,>= Integer resnum = 10\nresidue =,>,<,<=,>= Integer residue = 10\nchain  String chain A\nmodel  Integer model 1\nbeta =,>,<,<=,>= Real beta > 0.5\noccup =,>,<,<=,>= Real occup >= 0.3\nsegname  String segname PROT\nx =,>,<,<=,>= Real x >= 3.0\ny =,>,<,<=,>= Real y < 0.0\nz =,>,<,<=,>= Real z >= 1.0\n   ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"note: Note\nresnum is the residue number as written in the PDB file, while residue is the residue number counted sequentially in the file.index_pdb is the number written in the \"atom index\" field of the PDB file, while index is the sequential index of the atom in the file. ","category":"page"},{"location":"selections/#Special-macros:-proteins,-water","page":"Selections","title":"Special macros: proteins, water","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"Just use these keywords to select the residues matching the properties desired. ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Examples:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"aromatic = select(atoms,\"aromatic\")\n","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"aromatic = select(atoms,\"charged\")\n","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Available keywords:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Keywords  \nwater  \nprotein backbone sidechain\nacidic basic \naliphatic aromatic \ncharged neutral \npolar nonpolar \nhydrophobic  \n  ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"note: Note\nThe properties refer to protein residues and will return false to every non-protein residue. Thus, be careful with the use of not with these selections, as they might retrieve non-protein atoms.","category":"page"},{"location":"selections/#Retrieving-indices,-filtering,-etc","page":"Selections","title":"Retrieving indices, filtering, etc","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"If only the indices of the atoms are of interest, the Julia findall function can be used, by passing a Select object, or a regular  function, to select the atoms:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and residue <= 3\");\n\njulia> findall(Select(\"name CA\"), atoms)\n3-element Vector{Int64}:\n  5\n 15\n 26\n\njulia> findall(at -> name(at) == \"CA\", atoms)\n3-element Vector{Int64}:\n  5\n 15\n 26","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"note: Note\nAll indexing is 1-based. Thus, the first atom of the structure is atom 1.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The Select constructor can be used to feed simple selection syntax entries to  other Julia functions, such as findfirst, findlast, or filter:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and residue <= 3\");\n\njulia> filter(Select(\"name CA\"), atoms)\n   Vector{Atom{Nothing}} with 3 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       5   CA     ALA     A        1        1   -8.483  -14.912   -6.726  1.00  0.00     1    PROT         5\n      15   CA     CYS     A        2        2   -5.113  -13.737   -5.466  1.00  0.00     1    PROT        15\n      26   CA     ASP     A        3        3   -3.903  -11.262   -8.062  1.00  0.00     1    PROT        26\n\njulia> findfirst(Select(\"beta = 0.00\"), atoms)\n1","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"tip: Tip\nThe sel\"\" literal string macro is a shortcut for Select. Thus, these syntaxes are valid:julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and residue <= 3\");\n\njulia> name.(filter(sel\"name CA\", atoms))\n3-element Vector{InlineStrings.String7}:\n \"CA\"\n \"CA\"\n \"CA\"\n\njulia> findfirst(sel\"name CA\", atoms)\n5","category":"page"},{"location":"selections/#Use-Julia-functions-directly","page":"Selections","title":"Use Julia functions directly","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"Selections can be done using Julia functions directly, providing a greater control over the selection and, possibly, the use of user defined selection  functions. For example:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"myselection(atom) = (atom.x < 10.0 && atom.resname == \"GLY\") || (atom.name == \"CA\") \natoms = select(atoms, myselection)","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"or, for example, using Julia anonymous functions","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"select(atoms, at -> isprotein(at) && name(at) == \"O\" && atom.x < 10.0)","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The only requirement is that the function defining the selection receives an PDBTools.Atom as input, and returns true or false depending on the conditions required for the atom.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"note: Note\nThe macro-keywords described in the previous section can be used within  the Julia function syntax, but the function names start with is. For example:select(atoms, at -> isprotein(at) && resnum(at) in [ 1, 5, 7 ])Thus, the macro selection functions are: iswater,  isprotein,     isbackbone,    issidechain, isacidic,      isbasic,                   isaliphatic,   isaromatic,                ischarged,     isneutral,                 ispolar,       isnonpolar,                and ishydrophobic.                          ","category":"page"},{"location":"selections/#Using-VMD","page":"Selections","title":"Using VMD","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"VMD is a very popular and powerful package for visualization of simulations. It contains a very versatile library to read topologies and trajectory files, and a powerful selection syntax. We provide here a wrapper to VMD which enables using its capabilities.  ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"warning: Warning\nSome notable differences of the PDBTools.select function relative to the selection syntax of VMD are:VMD uses 0-based indexing. Thus, the first atom is atom 0 for VMD, and  atom 1 for PDBTools. Same for residue numbering. Be careful.\nVMD uses resid for the residue number as written in the PDB file, while PDBTools uses residue. \nVMD uses residue for the sequential number of the residue in the  PDB file, while PDBTools uses resnum.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The select_with_vmd input can be a vector of PDBTools.Atoms, or a filename. If the input is a vector of Atoms, the output will be the corresponding atoms matching the selection. If the input is a filename, two lists are returned: the list of indices and names of the corresponding atoms. This is because some input files supported by VMD (e. g. GRO, PSF, etc.) do not contain full atom information. ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"For example, here some atoms are selected from a previously loaded vector of atoms:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"julia> using PDBTools\n\njulia> pdbfile = PDBTools.SMALLPDB\n\njulia> atoms = read_pdb(pdbfile);\n\njulia> selected_atoms = select_with_vmd(atoms,\"resname ALA and name HT2 HT3\";vmd=\"/usr/bin/vmd\")\n   Vector{Atom{Nothing}} with 2 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       3  HT2     ALA     A        1        1   -9.488  -13.913   -5.295  0.00  0.00     1    PROT         3\n       4  HT3     ALA     A        1        1   -8.652  -15.208   -4.741  0.00  0.00     1    PROT         4","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"And, now, we provide the filename as input:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"julia> selected_atoms = select_with_vmd(pdbfile,\"resname ALA and name HT2 HT3\";vmd=\"/usr/bin/vmd\")\n([3, 4], [\"HT2\", \"HT3\"])","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Note that in the above examples we use name HT2 HT3 which is not currently supported by the  internal PDBTools select function, which would require name HT2 or name HT3. ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Here, the output will contain two lists, one of atom indices (one-based) and atom names. The indices correspond to sequential indices in the input, not the indices written in the PDB file, for example.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"tip: Tip\nIf vmd is available in your path, there is no need to pass it as a keyword parameter.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The main advantage here is that all the file types and the complete selection syntax  that VMD supports are supported. But VMD needs to be installed and is run in background, and it takes a few seconds to run.","category":"page"},{"location":"selections/#PDBTools.select_with_vmd","page":"Selections","title":"PDBTools.select_with_vmd","text":"select_with_vmd(atoms::AbstractVector{<:Atom}, selection::String; vmd=\"vmd\", srcload=nothing)\nselect_with_vmd(inputfile::String, selection::String; vmd=\"vmd\", srcload=nothing)\n\nSelect atoms using vmd selection syntax, with vmd in background. The input can be a file or a list of atoms.\n\nInput structure and output format:\n\natoms::AbstractVector{<:Atom}: A vector of PDBTools.Atom objects to select from. In this case, the output will be a vector of PDBTools.Atom objects that match the selection.\ninputfile::String: Path to the input file (e.g., PDB, PSF, GRO, etc.) or a temporary file containing atom data. In this case, two vectors will be returned: one with the indices of the selected atoms and another with their names.\n\nThe outputs are different in each case because VMD supports selections on files like PSF, GRO, etc., which do not  carry the full atom information like PDB files do.\n\nAdditional arguments:\n\nselection::String: A string containing the selection criteria in VMD syntax, e.g., \"protein and residue 1\".\nvmd::String: The command to run VMD. Default is \"vmd\", but can be set to the full path if VMD is not in the system PATH.\nsrcload::Union{Nothing, AbstractString, Vector{AbstractString}}: A script or a list of VMD scripts to load before executing the selection, for example with macros to define custom selection keywords.\n\nwarning: Warning\nVMD uses 0-based indexing, be careful to account for this when using indices in the selection string. If you want to suppress this warning, set index_warning=false in the function call.\n\n\n\n\n\n","category":"function"},{"location":"selections/#Loading-vmd-scripts","page":"Selections","title":"Loading vmd scripts","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"The select_with_vmd function also accepts an optional keyword parameter srcload, which can be used to load custom scripts within vmd before running setting the selection. This enables the definition of tcl scripts with custom selection macros, for instance. The usage would be: ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"sel = select_with_vmd(\"file.pdb\", \"resname MYRES\"; srcload = [ \"mymacros1.tcl\", \"mymacros2.tcl\" ])","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Which corresponds to sourceing each of the macro files in VMD before defining the  selection with the custom MYRES name.","category":"page"},{"location":"elements/#Atomic-and-molecular-properties","page":"Atom and element properties","title":"Atomic and molecular properties","text":"","category":"section"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"Some simple atom properties can be retrieved using special functions, which operate on atoms of the type Atom. For example:","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"julia> atoms = read_pdb(\"./file.pdb\");\n\njulia> printatom(atoms[1])\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1   OW     SOL     X        1        1   54.370   45.310   33.970  0.00  0.00     1       -         1\n\njulia> mass(atoms[1])\n14.0067\n\njulia> atomic_number(atoms[1])\n7\n\njulia> element(atoms[1])\n\"N\"\n\njulia> element_name(atoms[1])\n\"Nitrogen\"","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"The formula or stoichiometry of a selection can also be retrieved:","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"julia> atoms = wget(\"1LBD\",\"protein and residue 1\");\n\njulia> f = formula(atoms)\nC₃N₁O₂\n\njulia> stoichiometry(select(atoms,\"water\"))\nH₂O₁\n","category":"page"},{"location":"elements/#PDBTools.mass","page":"Atom and element properties","title":"PDBTools.mass","text":"mass(s::Sequence)\n\nReturns the mass of a sequence of amino acids, given a Sequence struct type.\n\nExamples\n\njulia> seq = [\"Alanine\", \"Glutamic acid\", \"Glycine\"];\n\njulia> mass(Sequence(seq))\n257.2432\n\njulia> seq = \"AEG\";\n\njulia> mass(Sequence(seq))\n257.2432\n\njulia> seq = [\"ALA\", \"GLU\", \"GLY\"];\n\njulia> mass(Sequence(seq))\n257.2432\n\n\n\n\n\nmass(atom::Atom)\nmass(atoms::AbstractVector{<:Atoms})\n\nReturns the mass of an atom given its name, or Atom structure, or the total mass of a vector of Atoms. \n\nIf a mass is defined as a custom field in the the Atom structure, it is returned. Otherwise, the mass is retrieved from the element mass as inferred from the atom name.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = [ Atom(name=\"NT3\"), Atom(name=\"CA\") ];\n\njulia> mass(atoms[1])\n14.0067f0\n\njulia> mass(atoms)\n26.0177f0\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element","page":"Atom and element properties","title":"PDBTools.element","text":"element(atom::Atom)\n\nReturns the element symbol, as a string, of an atom given the Atom structure. If the pdb_element is empty or \"X\", the element is inferred from the atom name.  Otherwise, the pdb_element is returned.\n\nExample\n\njulia> using PDBTools\n\njulia> at = Atom(name=\"NT3\");\n\njulia> element(at)\n\"N\"\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element_name","page":"Atom and element properties","title":"PDBTools.element_name","text":"element_name(atom::Atom)\n\nReturns the element name of an atom given its name, or Atom structure.\n\nExample\n\njulia> using PDBTools\n\njulia> at = Atom(name=\"NT3\");\n\njulia> element_name(at)\n\"Nitrogen\"\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element_symbol","page":"Atom and element properties","title":"PDBTools.element_symbol","text":"element_symbol(atom::Atom)\n\nReturns a symbol for element name of an atom given its name, or Atom structure.\n\nExample\n\njulia> using PDBTools \n\njulia> at = Atom(name=\"NT3\");\n\njulia> element_symbol(at)\n:N\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element_symbol_string","page":"Atom and element properties","title":"PDBTools.element_symbol_string","text":"element_symbol_string(atom::Atom)\n\nReturns a string with the symbol of the element, given the Atom structure.\n\nExample\n\njulia> using PDBTools \n\njulia> at = Atom(name=\"NT3\");\n\njulia> element_symbol_string(at)\n\"N\"\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element_vdw_radius","page":"Atom and element properties","title":"PDBTools.element_vdw_radius","text":"element_vdw_radius(atom::Atom)\n\nReturns the vdW radius of the element of the atom, in Å, or NaN if the data is not available.\n\nExample\n\njulia> using PDBTools \n\njulia> at = Atom(name=\"NT3\");\n\njulia> element_vdw_radius(at)\n1.55f0\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.formula","page":"Atom and element properties","title":"PDBTools.formula","text":"formula(atoms::AbstractVector{<:Atom})\n\nReturns the molecular formula of the current selection. The output is an indexable \"Formula\" structure, where each element is a tuple with the element name and the number of atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> pdb  = read_pdb(PDBTools.TESTPDB, \"residue 1\"); # testing PDB file\n\njulia> resname(pdb[1])\n\"ALA\"\n\njulia> f = formula(pdb)\nH₇C₃N₁O₁\n\njulia> f[1]\n(\"H\", 7)\n\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.stoichiometry","page":"Atom and element properties","title":"PDBTools.stoichiometry","text":"stoichiometry(atoms::AbstractVector{<:Atom})\n\nReturns the stoichiometry of atom selection in a Formula structure. \n\nExample\n\njulia> using PDBTools\n\njulia> pdb  = read_pdb(PDBTools.TESTPDB, \"water\"); # testing PDB file\n\njulia> stoichiometry(pdb)\nH₂O₁\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.printatom","page":"Atom and element properties","title":"PDBTools.printatom","text":"printatom(atom::Atom)\nprintatom(io::IO, atom::Atom)\n\nPrints an Atom structure in a human-readable format, with a title line. By default the output is printed to stdout, and the io argument can be used to specify a different output stream.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and residue 2\");\n\njulia> printatom(atoms[1])\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n      13    N     CYS     A        2        2   -6.351  -14.461   -5.695  1.00  0.00     1    PROT        13\n\njulia> atoms[1] # default show method\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n      13    N     CYS     A        2        2   -6.351  -14.461   -5.695  1.00  0.00     1    PROT        13\n\n\n\n\n\n","category":"function"},{"location":"elements/#custom-atom-fields","page":"Atom and element properties","title":"Custom Atom fields","text":"","category":"section"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"Custom atom fields can be created in Atom objects by defining the custom keyword. By default, custom == nothing. The custom fields can be added on construction, or  with the add_custom_field function, which creates a new instance of an Atom  with the added value in the custom field:","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"For example:","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"julia> using PDBTools\n\njulia> atom = Atom(custom=\"TEST\");\n\njulia> atom.custom\n\"TEST\"\n\njulia> atom = Atom(;name = \"CA\", resname=\"ALA\"); # no custom field\n\njulia> atom.resname\n\"ALA\"\n\njulia> new_atom = add_custom_field(atom, Dict(:charge => 2.0));\n\njulia> new_atom.resname\n\"ALA\"\n\njulia> new_atom.custom[:charge]\n2.0\n","category":"page"},{"location":"elements/#PDBTools.add_custom_field","page":"Atom and element properties","title":"PDBTools.add_custom_field","text":"add_custom_field(atom::Atom, value)\n\nAdds a custom field to an Atom structure, returning a new Atom structure with the custom field added. The returning Atom structure is parameterized with the type of value.\n\n\n\n\n\n","category":"function"},{"location":"elements/#Elements-for-custom-atom-types","page":"Atom and element properties","title":"Elements for custom atom types","text":"","category":"section"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"The types of atoms that PDBTools recognizes is defined in the PDBTools.elements dictionary.  If new atom types are defined, it is possible to add these types to the dictionary, such that other functions work for the new types. The function to be used is add_element!.","category":"page"},{"location":"elements/#PDBTools.add_element!","page":"Atom and element properties","title":"PDBTools.add_element!","text":"add_element!(symbol::String, reference_element::PDBTools.Element; elements=PDBTools.elements)\n\nAdd a new element to the elements dictionary. If the element already exists, overwrite it.\n\nTo remove all custom elements, use remove_custom_elements!().\n\nExample\n\njulia> using PDBTools\n\njulia> remove_custom_elements!(); # if any\n\njulia> atoms = [ Atom(name=\"A1\"), Atom(name=\"A2\") ];\n\njulia> add_element!(\"A1\", PDBTools.elements[\"C\"])\nPDBTools.Element(:C, InlineStrings.String3(\"C\"), \"Carbon\", 6, 12.011f0, true, 1.7f0)\n\njulia> add_element!(\"A2\", PDBTools.elements[\"N\"])\nPDBTools.Element(:N, InlineStrings.String3(\"N\"), \"Nitrogen\", 7, 14.0067f0, true, 1.55f0)\n\njulia> element(atoms[1])\n\"C\"\n\njulia> element(atoms[2])\n\"N\"\n\njulia> mass(atoms)\n26.0177f0\n\njulia> remove_custom_elements!(); \n\nHere we repeteadly call remove_custom_elements!() to guarantee the proper execution of the test codes, without any custom elements predefined.\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.remove_custom_elements!","page":"Atom and element properties","title":"PDBTools.remove_custom_elements!","text":"remove_custom_elements!()\n\nRemove all custom elements from the elements dictionary.\n\nExample\n\njulia> using PDBTools\n\njulia> remove_custom_elements!();\n\njulia> add_element!(\"GN\", PDBTools.elements[\"N\"])\nPDBTools.Element(:N, InlineStrings.String3(\"N\"), \"Nitrogen\", 7, 14.0067f0, true, 1.55f0)\n\njulia> element(Atom(name=\"GN\"))\n\"N\"\n\njulia> remove_custom_elements!();\n\njulia> element(Atom(name=\"GN\")) # returns `nothing`\n\n\nHere we repeatedly call remove_custom_elements!() to guarantee the proper execution of the test codes, without any custom elements predefined.\n\n\n\n\n\n","category":"function"},{"location":"elements/#Additional-property-retrieving-and-set-functions","page":"Atom and element properties","title":"Additional property-retrieving and set functions","text":"","category":"section"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"The following functions are supported as part of the API, as a intending to interface with AtomsBase. Nevertheless, currently these functions do not overload the exported ones from AtomsBase, because that package is in a unstable state.","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"Function Example Output\natomic_number(::Atom) atomic_number(Atom(name=\"NE2\")) 7\natomic_symbol(::Atom) atomic_symbol(Atom(name=\"NE2\")) :N\natomic_mass(::Atom) atomic_mass(Atom(name=\"NE2\")) 14.0067\nposition(::Atom) position(Atom(name=\"NE2\")) SVector{3,Float64}(0,0,0)\nset_position!(::Atom, x::Union{Tuple,AbstractVector}) set_position!(at, (1,2,3)) Atom","category":"page"},{"location":"elements/#PDBTools.atomic_number","page":"Atom and element properties","title":"PDBTools.atomic_number","text":"atomic_number(atom::Atom)\n\nReturns the atomic number of an atom from its Atom structure.\n\nExample\n\njulia> using PDBTools\n\njulia> at = Atom(name=\"NT3\");\n\njulia> atomic_number(at)\n7\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.atomic_symbol","page":"Atom and element properties","title":"PDBTools.atomic_symbol","text":"atomic_symbol(atom::Atom)\n\nReturns the atomic symbol of an atom given the Atom structure.\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.atomic_mass","page":"Atom and element properties","title":"PDBTools.atomic_mass","text":"atomic_mass(atom::Atom)\n\nReturns the atomic mass of an atom given the Atom structure.\n\n\n\n\n\n","category":"function"},{"location":"elements/#Base.position","page":"Atom and element properties","title":"Base.position","text":"position(atom::Atom)\n\nReturns the position of an atom given the Atom structure.\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.set_position!","page":"Atom and element properties","title":"PDBTools.set_position!","text":"set_position!(atom::Atom, x::Union{Tuple,AbstractVector})\n\nSets the position (x,y,z coordinates) of the atom, given a vector or tuple of coordinates.\n\n\n\n\n\n","category":"function"},{"location":"iterators/#Iterators","page":"Iterators","title":"Iterators","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"PDBTools.jl provides lazy iterators over Residues, Chains, Segments, and Models of a structure file. The iterators behave similarly, and can be used bo computed properties of independent structural elements. The documentation bellow exemplifies in more detail the features associated to Residue and Chain interators, but the properties and valid for Segment and Model iterators similarly.","category":"page"},{"location":"iterators/#Iterate-over-residues-(or-molecules)","page":"Iterators","title":"Iterate over residues (or molecules)","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The eachresidue iterator enables iteration over the residues of a structure. In PDB files, distinct molecules are often treated as separate residues, so this iterator can be used to iterate over the molecules within a structure. For example:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PDBTools\nprotein = read_pdb(PDBTools.SMALLPDB);\ncount(res -> resname(res) == \"ALA\", eachresidue(protein))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Here, we use eachresidue to count the number of residues named \"ALA\". This highlights the distinction between residue-level and atom-level operations.","category":"page"},{"location":"iterators/#Collecting-Residues-into-a-Vector","page":"Iterators","title":"Collecting Residues into a Vector","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Residues produced by eachresidue can be collected into a vector for further processing:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"residues = collect(eachresidue(protein))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"and the atoms of a specific residue can be seen by indexing the residue:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"residues[1]","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"note: Note\nIterators or collected vectors do not create copies of the original atom data. This means that any changes made to the residue vector will directly modify the corresponding data in the original atom vector.","category":"page"},{"location":"iterators/#Iterating-Over-Atoms-Within-Residues","page":"Iterators","title":"Iterating Over Atoms Within Residues","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"You can iterate over the atoms of one or more residues using nested loops. Here, we compute the total number of atoms of ALA residues: ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"let n_ala_cys = 0\n    for residue in eachresidue(protein)\n        if name(residue) in (\"ALA\", \"CYS\")\n            for atom in residue\n                n_ala_cys += 1\n            end\n        end\n    end\n    n_ala_cys\nend","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"This method produces the same result as the more concise approach:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"sum(length(r) for r in eachresidue(protein) if name(r) in (\"ALA\", \"CYS\"))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Alternativelly, an image (not a copy!) of the atoms corresponding to a residue can be obtained with get_atoms:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"r1_atoms = get_atoms(residues[1])","category":"page"},{"location":"iterators/#Reference-documentation","page":"Iterators","title":"Reference documentation","text":"","category":"section"},{"location":"iterators/#PDBTools.Residue","page":"Iterators","title":"PDBTools.Residue","text":"Residue\n\nResidue data structure. \n\nThe Residue structure carries the properties of the residue or molecule of the atoms it contains, but it does not copy the original vector of atoms, only the residue meta data for each residue. Thus, changes in the residue atoms will be reflected in the original vector of atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> pdb = wget(\"1LBD\");\n\njulia> residues = collect(eachresidue(pdb))\n238-element Vector{Residue}[\n    SER225A\n    ALA226A\n    ⋮\n    MET461A\n    THR462A\n]\n\njulia> resnum.(residues[1:3])\n3-element Vector{Int32}:\n 225\n 226\n 227\n\njulia> residues[5].chain\n\"A\"\n\njulia> residues[8].range\n52:58\n\njulia> mass(residues[1])\n82.0385f0\n\n\n\n\n\n\n","category":"type"},{"location":"iterators/#PDBTools.eachresidue","page":"Iterators","title":"PDBTools.eachresidue","text":"eachresidue(atoms::AbstractVector{<:Atom})\n\nIterator for the residues (or molecules) of a selection. \n\nExample\n\njulia> using PDBTools\n\njulia> atoms = wget(\"1LBD\");\n\njulia> eachresidue(atoms)\n Residue iterator with length = 238\n\njulia> collect(eachresidue(atoms))\n238-element Vector{Residue}[\n    SER225A\n    ALA226A\n    ⋮\n    MET461A\n    THR462A\n]\n\n\n\n\n\n","category":"function"},{"location":"iterators/#PDBTools.resname","page":"Iterators","title":"PDBTools.resname","text":"resname(residue::Union{AbstractString,Char})\n\nReturns the residue name, given the one-letter code or residue name. Differently from threeletter, this function will return the force-field name if available in the list of protein residues.\n\nExamples\n\njulia> resname(\"ALA\")\n\"ALA\"\n\njulia> resname(\"GLUP\")\n\"GLUP\"\n\n\n\n\n\n","category":"function"},{"location":"iterators/#PDBTools.residuename","page":"Iterators","title":"PDBTools.residuename","text":"residuename(residue::Union{AbstractString,Char})\n\nFunction to return the long residue name from other residue codes. The function is case-insensitive.\n\nExamples\n\njulia> residuename(\"A\")\n\"Alanine\"\n\njulia> residuename(\"Glu\")\n\"Glutamic Acid\"\n\n\n\n\n\n\n","category":"function"},{"location":"iterators/#Iterate-over-chains","page":"Iterators","title":"Iterate over chains","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The eachchain iterator in PDBTools enables users to iterate over the chains in a PDB structure. A PDB file may contain multiple protein chains. This iterator simplifies operations involving individual chains.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"ats = read_pdb(PDBTools.CHAINSPDB);\nchain.(eachchain(ats)) # Retrieve the names of all chains in the structure","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"model.(eachchain(ats)) # Retrieve the model numbers associated with each chain","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"chain_A1 = first(eachchain(ats)); # Access the first chain in the iterator","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"resname.(eachresidue(chain_A1)) # Retrieve residue names for chain A in model 1","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"In the example above, the chain. command retrieves the names of all chains in the structure, while  model. command lists the model numbers for each chain. This PDB structure contains two models for chain A, where the third residue changes from leucine (LEU) in model 1 to valine (VAL) in model 2.","category":"page"},{"location":"iterators/#Collect-chains-and-indexing","page":"Iterators","title":"Collect chains and indexing","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"As seen in the previous example, The first and last commands allow quick access to the first an last elements in the iterator. For more specific indexing, you can collect all chains into an array and then use numerical indices to access them.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"chains = collect(eachchain(ats))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"chain_B = chains[2]","category":"page"},{"location":"iterators/#Modifying-Atom-Properties-in-a-Chain","page":"Iterators","title":"Modifying Atom Properties in a Chain","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Any changes made to the atoms of a chain variable directly overwrite the properties of the original atoms in the structure. For example, modifying the occupancy and beta-factor columns of atoms in model 2 of chain A will update the corresponding properties in the original structure.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"In the example below, the occup and beta properties of all atoms in model 2 of chain A are set to 0.00. The changes are reflected in the original ats vector, demonstrating that the modifications propagate to the parent data structure.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"first(eachchain(ats))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"for chain in eachchain(ats)\n    if name(chain) == \"A\" && model(chain) == 1\n        for atom in chain\n            atom.occup = 0.00\n            atom.beta = 0.00\n        end\n    end\nend\nfirst(eachchain(ats))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"This behavior ensures efficient data manipulation but requires careful handling to avoid unintended changes. ","category":"page"},{"location":"iterators/#Reference-documentation-2","page":"Iterators","title":"Reference documentation","text":"","category":"section"},{"location":"iterators/#PDBTools.Chain","page":"Iterators","title":"PDBTools.Chain","text":"Chain\n\nCreates a Chain data structure. Chains must be consecutive in the atoms vector, and are identified by having the same chain, segment, and model fields.\n\nThe Chain structure carries the properties of the atoms it contains, but it does not copy the original vector of atoms. This means that any changes made in the Chain structure atoms, will overwrite the original vector of atoms. \n\nExamples\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.CHAINSPDB);\n\njulia> chains = collect(eachchain(ats))\n4-element Vector{Chain}[\n    Chain(A-48 atoms)\n    Chain(B-48 atoms)\n    Chain(A-48 atoms)\n    Chain(D-45 atoms)\n]\n\njulia> chains[1]\n Chain A with 48 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ASP     A        1        1  133.978  119.386  -23.646  1.00  0.00     1    ASYN         1\n       2   CA     ASP     A        1        1  134.755  118.916  -22.497  1.00  0.00     1    ASYN         2\n⋮\n      47 HD23     LEU     A        3        3  130.568  111.868  -26.242  1.00  0.00     1    ASYN        47\n      48    O     LEU     A        3        3  132.066  112.711  -21.739  1.00  0.00     1    ASYN        48\n\njulia> mass(chains[1])\n353.3787f0 \n\njulia> model(chains[4])\n2\n\njulia> segname(chains[2])\n\"ASYN\"\n\n\n\n\n\n","category":"type"},{"location":"iterators/#PDBTools.eachchain","page":"Iterators","title":"PDBTools.eachchain","text":"eachchain(atoms::AbstractVector{<:Atom})\n\nIterator for the chains of a selection. \n\nExample\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.CHAINSPDB);\n\njulia> eachchain(ats)\n Chain iterator with length = 4\n\njulia> chains = collect(eachchain(ats))\n4-element Vector{Chain}[\n    Chain(A-48 atoms)\n    Chain(B-48 atoms)\n    Chain(A-48 atoms)\n    Chain(D-45 atoms)\n]\n\n\n\n\n\n","category":"function"},{"location":"iterators/#Iterate-over-segments","page":"Iterators","title":"Iterate over segments","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The eachsegment iterator enables iteration over the segments of a structure. For example:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"read_pdb(PDBTools.DIMERPDB)\neachsegment(ats)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"name.(eachsegment(ats))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The result of the iterator can also be collected, with:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"s = collect(eachsegment(ats))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"s[1]","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"These segment structure does not copy the data from the original atom vector. Therefore, changes performed on these vectors will be reflected on the original data.  ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Iterators can be used to obtain or modify properties of the segments. Here we illustrate computing the mass of each segment and renaming segment of all atoms with the segment indices:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"s = collect(eachsegment(ats))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Properties of each segment can then be obtained by broadcasting over the segments:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"mass.(s)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"formula.(s)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"And iterating over the segments can allow changing properties of the atoms in a segment-specific way. For instance, here we change the segment names:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"for (iseg, seg) in enumerate(eachsegment(ats))\n    for at in seg\n        at.segname = \"$(at.segname)$iseg\"\n    end\nend","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"collect(eachsegment(ats))","category":"page"},{"location":"iterators/#Reference-documentation-3","page":"Iterators","title":"Reference documentation","text":"","category":"section"},{"location":"iterators/#PDBTools.Segment","page":"Iterators","title":"PDBTools.Segment","text":"Segment\n\nSegment data structure. Segments must be consecutive in the atoms vector, and are identified by having the same segname and model fields.\n\nThe Segment structure carries the properties of the segment  it contains, but it does not copy the original vector of atoms, only the segment meta data and the reference to the original vector. Thus, changes in the segment atoms will be reflected in the original vector of atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> segments = collect(eachsegment(ats))\n2-element Vector{Segment}[\n    A-(1905 atoms))\n    B-(92 atoms))\n]\n\njulia> segname.(segments[1:2])\n2-element Vector{InlineStrings.String7}:\n \"A\"\n \"B\"\n\njulia> length(segments[2])\n92\n\n\n\n\n\n\n","category":"type"},{"location":"iterators/#PDBTools.eachsegment","page":"Iterators","title":"PDBTools.eachsegment","text":"eachsegment(atoms::AbstractVector{<:Atom})\n\nIterator for the segments of a selection.\n\nExample\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> sit = eachsegment(ats)\n Segment iterator with length = 2\n\njulia> for seg in sit\n           @show length(seg)\n       end\nlength(seg) = 1905\nlength(seg) = 92\n\njulia> collect(sit)\n2-element Vector{Segment}[ \n    A-(1905 atoms))\n    B-(92 atoms))\n]\n\n\n\n\n\n","category":"function"},{"location":"iterators/#Iterate-over-models","page":"Iterators","title":"Iterate over models","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The eachmodel iterator enables iteration over the segments of a structure. For example:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"ats = wget(\"8S8N\");\neachmodel(ats)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"model.(eachmodel(ats))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The result of the iterator can also be collected, with:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"m = collect(eachmodel(ats))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"m[1]","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The model structure does not copy the data from the original atom vector. Therefore, changes performed on these vectors will be reflected on the original data.  ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Iterators can be used to obtain or modify properties of the models. Here we illustrate computing the mass of each segment and renaming segment of all atoms with the segment indices:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"center_of_mass.(eachmodel(ats))","category":"page"},{"location":"iterators/#Reference-documentation-4","page":"Iterators","title":"Reference documentation","text":"","category":"section"},{"location":"iterators/#PDBTools.Model","page":"Iterators","title":"PDBTools.Model","text":"Model\n\nModel data structure. It carries the data of a model in a PDB file. Models must be consecutive in the atoms vector, and are identified by having the same model field.\n\nThe Model structure carries the properties of the model it contains, but it does not copy the original vector of atoms, only the model meta data and the reference to the original vector. Thus, changes in the model atoms will be reflected in the original vector of atoms.\n\nExample\n\nIn the example below, 8S8N is PDB entry with 11 models.\n\njulia> using PDBTools\n\njulia> ats = wget(\"8S8N\");\n\njulia> models = collect(eachmodel(ats))\n11-element Vector{Model}[\n    1-(234 atoms))\n    2-(234 atoms))\n    ⋮\n    10-(234 atoms))\n    11-(234 atoms))\n]\n\njulia> models[1]\n Model 1 with 234 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     DLE     A        2        1   -5.811   -0.380   -2.159  1.00  0.00     1                 1\n       2   CA     DLE     A        2        1   -4.785   -0.493   -3.227  1.00  0.00     1                 2\n⋮\n     233  HT2   A1H5T     B      101       13   -5.695    5.959   -3.901  1.00  0.00     1               233\n     234  HT1   A1H5T     B      101       13   -4.693    4.974   -2.743  1.00  0.00     1               234\n\n\n\n\n\n\n","category":"type"},{"location":"iterators/#PDBTools.eachmodel","page":"Iterators","title":"PDBTools.eachmodel","text":"eachmodel(atoms::AbstractVector{<:Atom})\n\nIterator for the models of a selection.\n\nExample\n\nHere we show how to iterate over the models of a PDB file, annotate  the index of the first atom of each model, and collect all models.\n\njulia> using PDBTools\n\njulia> ats = wget(\"8S8N\");\n\njulia> models = eachmodel(ats)\n Model iterator with length = 11\n\njulia> first_atom = Atom[]\n       for model in models\n           push!(first_atom, model[1])\n       end\n       @show index.(first_atom);\nindex.(first_atom) = Int32[1, 235, 469, 703, 937, 1171, 1405, 1639, 1873, 2107, 2341]\n\njulia> collect(models)\n11-element Vector{Model}[\n    1-(234 atoms))\n    2-(234 atoms))\n    ⋮\n    10-(234 atoms))\n    11-(234 atoms))\n]\n\n\n\n\n\n","category":"function"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"These tools may call external programs to perform each task. Please verify the installation of  the necessary tool for each case. ","category":"page"},{"location":"tools/#Add-hydrogens-with-OpenBabel","page":"Tools","title":"Add hydrogens with OpenBabel","text":"","category":"section"},{"location":"tools/#PDBTools.add_hydrogens!","page":"Tools","title":"PDBTools.add_hydrogens!","text":"add_hydrogens!(atoms::AbstractVector{<:Atom}; pH=7.0, obabel=\"obabel\", debug=false)\n\nAdd hydrogens to a PDB file using Open Babel. \n\nArguments\n\natoms::AbstractVector{<:Atom}: structure (usually PDB file of a protein) to add hydrogens to.\npH: the pH of the solution. Default is 7.0.\nobabel: path to the obabel executable. Default is \"obabel\".\ndebug: if true, print the output message from obabel. Default is false.\n\nnote: Note\nThis function requires the installation of OpenBabel. Please cite the corresponding reference if using it.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and not element H\");\n\njulia> add_hydrogens!(atoms)\n   Vector{Atom{Nothing}} with 1459 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  1.00  0.00     1       -         1\n       2   CA     ALA     A        1        1   -8.483  -14.912   -6.726  1.00  0.00     1       -         2\n       3   CB     ALA     A        1        1   -9.383  -14.465   -7.880  1.00  0.00     1       -         3\n                                                       ⋮ \n    1457    H     THR     A      104      208    5.886  -10.722   -7.797  1.00  0.00     1       -      1457\n    1458    H     THR     A      104      208    5.871  -10.612   -9.541  1.00  0.00     1       -      1458\n    1459    H     THR     A      104      208    6.423  -12.076   -8.762  1.00  0.00     1       -      1459\n\n\n\n\n\n","category":"function"},{"location":"tools/#Custom-protein-residue-types","page":"Tools","title":"Custom protein residue types","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"It is possible to add to the list of protein residues, custom residue types.  This can be done by simply adding to the PDBTools.protein_residues dictionary of residues a new PDBTools.ProteinResidue entry. For example, here we create a new resiude type NEW with the same properties of an ALA residue. To  remove all custom protein residues, use remove_custom_protein_residues!().","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"julia> using PDBTools\n\njulia> remove_custom_protein_residues!();\n\njulia> add_protein_residue!(\"NEW\", PDBTools.protein_residues[\"ALA\"])\nPDBTools.ProteinResidue(\"NEW\", \"ALA\", \"A\", \"Aliphatic\", false, true, 71.037114, 71.0779, 0, true)\n\njulia> atom = Atom(resname=\"NEW\");\n\njulia> isprotein(atom)\ntrue\n\njulia> remove_custom_protein_residues!();","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Here we repeteadly call remove_custom_residues!() to guarantee the proper execution of the test codes, without any custom residues in the list of protein residues.","category":"page"},{"location":"tools/#PDBTools.add_protein_residue!","page":"Tools","title":"PDBTools.add_protein_residue!","text":"add_protein_residue!(resname::String, reference_residue::PDBTools.ProteinResidue)\n\nFunction to add a custom protein residue to the list of protein residues. The function will return the ProteinResidue object that was added. To remove all custom protein residues use remove_custom_protein_residues!().\n\nExample\n\njulia> using PDBTools\n\njulia> remove_custom_protein_residues!();\n\njulia> add_protein_residue!(\"sA\", PDBTools.protein_residues[\"ALA\"])\nPDBTools.ProteinResidue(\"sA\", \"ALA\", \"A\", \"Aliphatic\", false, true, 71.037114, 71.0779, 0, true)\n\njulia> isprotein(Atom(resname=\"sA\"))\ntrue\n\njulia> remove_custom_protein_residues!(); # clean up\n\nHere we repeatedly call remove_custom_residues!() to guarantee the proper execution of the test codes, without any custom residues in the list of protein residues.\n\n\n\n\n\n","category":"function"},{"location":"tools/#PDBTools.remove_custom_protein_residues!","page":"Tools","title":"PDBTools.remove_custom_protein_residues!","text":"remove_custom_protein_residues!()\n\nFunction to remove all custom protein residues from the list of protein residues.\n\nExample\n\njulia> using PDBTools\n\njulia> remove_custom_protein_residues!(); # clean up\n\njulia> add_protein_residue!(\"sA\", PDBTools.protein_residues[\"ALA\"])\nPDBTools.ProteinResidue(\"sA\", \"ALA\", \"A\", \"Aliphatic\", false, true, 71.037114, 71.0779, 0, true)\n\njulia> isprotein(Atom(resname=\"sA\"))\ntrue\n\njulia> remove_custom_protein_residues!();\n\njulia> isprotein(Atom(resname=\"sA\"))\nfalse\n\nHere we repeatedly call remove_custom_residues!() to guarantee the proper execution of the test codes, without any custom residues in the list of protein residues.\n\n\n\n\n\n","category":"function"},{"location":"tools/#The-SIRAH-force-field-residues-and-element-types","page":"Tools","title":"The SIRAH force-field residues and element types","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Conveniencie functions can be created to add sets of new types of residues and atom types to the list of residues and elements. This is illustrated in the  custom_types.jl file of the source code, in this case for the residues and atom types of the SIRAH force field for Coarse-Grained protein simulations.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"With those definitions, adding all SIRAH protein residue types and element names can be done with:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"julia> using PDBTools \n\njulia> remove_custom_protein_residues!(); remove_custom_elements!();\n\njulia> custom_protein_residues!(SIRAH)\n┌ Warning: \n│ \n│     Residue `sX` will be interpreted as bridged Cysteine.\n│ \n└ @ PDBTools\n\njulia> custom_elements!(SIRAH)\n┌ Warning:\n│\n│     The element masses are not the coarse-grained ones. This must be fixed in the future.\n│\n└ @ PDBTools\n\njulia> sirah_pdb = read_pdb(PDBTools.SIRAHPDB);\n\njulia> resname.(eachresidue(sirah_pdb))\n5-element Vector{InlineStrings.String7}:\n \"sI\"\n \"sR\"\n \"sX\"\n \"sI\"\n \"sG\"\n\njulia> getseq(sirah_pdb)\n5-element Vector{String}:\n \"I\"\n \"R\"\n \"C\"\n \"I\"\n \"G\"\n\njulia> all(isprotein.(sirah_pdb))\ntrue\n\njulia> remove_custom_protein_residues!(); remove_custom_elements!();","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Note that the residue names of the SIRAH force-field are non-standard (sI, sR, etc.), but the sequence is properly retrieved with standard one-letter codes, and all the atoms of the structure are recognized  as being \"protein\" atoms.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Here we repeteadly call remove_custom_residues!() and remove_custom_elements!() to guarantee the proper execution of the test codes.","category":"page"},{"location":"tools/#Move-atoms-and-center-of-mass","page":"Tools","title":"Move atoms and center of mass","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The center_of_mass function can be used to compute the center of mass of set of atoms, and the  moveto! function can be used to move the center of mass of the atoms to the origin (by default)  or to a specified position:","category":"page"},{"location":"tools/#MolSimToolkitShared.center_of_mass","page":"Tools","title":"MolSimToolkitShared.center_of_mass","text":"center_of_mass(atoms::AbstractVector{<:Atom})\n\nCalculate the center of mass of the atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> center_of_mass(atoms)\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n  -5.5844226\n -13.1104145\n  -7.1399713\n\n\n\n\n\n","category":"function"},{"location":"tools/#PDBTools.moveto!","page":"Tools","title":"PDBTools.moveto!","text":"moveto!(atoms::AbstractVector{<:Atom}; center::AbstractVector{<:Real}=SVector(0.0, 0.0, 0.0))\n\nMove the center of mass of the atoms to the specified center position, which defaults to the origin.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> center_of_mass(atoms)\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n  -5.5844226\n -13.1104145\n  -7.1399713\n\njulia> moveto!(atoms; center = [1.0, 2.0, 3.0]);\n\njulia> center_of_mass(atoms)\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n 1.0\n 2.0000014\n 3.0\n\n\n\n\n\n","category":"function"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Selecting-the-active-site-of-a-protein","page":"Examples","title":"Selecting the active site of a protein","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 1BSX pdb file is a structure that contains a dimer of the thyroid hormone receptor-beta bound to the ligand T3. Here we select all residues of chain A, which is one of the monomers, that within 3.5AA of the ligand:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using PDBTools\n\njulia> atoms = wget(\"1BSX\", \"chain A\"; format=\"PDB\");\n\njulia> protein = select(atoms, \"protein\");\n\njulia> ligand = select(atoms, \"resname T3\");\n\njulia> active_site_atoms = Atom[]\n       for residue in eachresidue(protein)\n           if distance(residue, ligand) < 3.5\n               append!(active_site_atoms, atom for atom in residue)\n           end\n       end\n\njulia> length(active_site_atoms)\n56\n\njulia> resname.(eachresidue(active_site_atoms))\n6-element Vector{InlineStrings.String7}:\n \"PHE\"\n \"ARG\"\n \"LEU\"\n \"ASN\"\n \"LEU\"\n \"HIS\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nThe Atom[] creates an empty vector of PDBTools.Atom objects, and we append to this array the list of atoms of each residue. \nWe opt here to download the file in the \"PDB\" format, because the chain identifier in the mmCIF deposited file does not include the ligand in chain A.","category":"page"},{"location":"examples/#Storing-partial-charges","page":"Examples","title":"Storing partial charges","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we exemplify the use of a custom field to store partial charges for all atoms in a protein:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using PDBTools\n\njulia> ats = wget(\"1BSX\", \"protein\");\n\njulia> charges = ones(length(ats));\n\njulia> ats_with_charges = add_custom_field.(ats, charges); # charges in custom field\n\njulia> ats_with_charges[1].custom\n1.0\n","category":"page"},{"location":"readwrite/#Read-and-write-files","page":"Read and Write","title":"Read and write files","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"PDBTools can read and write PDB and mmCIF files. The relevant functions are:","category":"page"},{"location":"readwrite/#PDBTools.read_pdb","page":"Read and Write","title":"PDBTools.read_pdb","text":"read_pdb(pdbfile::String, selection::String)\nread_pdb(pdbfile::String, selection_function::Function = all)\n\nread_pdb(pdbdata::IOBuffer, selection::String)\nread_pdb(pdbdata::IOBuffer, selection_function::Function = all)\n\nReads a PDB file and stores the data in a vector of type Atom. \n\nIf a selection is provided, only the atoms matching the selection will be read.  For example, resname ALA will select all the atoms in the residue ALA.\n\nIf a selection function keyword is provided, only the atoms for which selection_function(atom) is true will be read.\n\nExamples\n\njulia> using PDBTools\n\njulia> protein = read_pdb(PDBTools.TESTPDB)\n   Vector{Atom{Nothing}} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  1.00  0.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  1.00  0.00     1    WAT2     62026\n\njulia> ALA = read_pdb(PDBTools.TESTPDB,\"resname ALA\")\n   Vector{Atom{Nothing}} with 72 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n    1339    C     ALA     A       95       95   14.815   -3.057   -5.633  1.00  0.00     1    PROT      1339\n    1340    O     ALA     A       95       95   14.862   -2.204   -6.518  1.00  0.00     1    PROT      1340\n\njulia> ALA = read_pdb(PDBTools.TESTPDB, atom -> atom.resname == \"ALA\")\n   Vector{Atom{Nothing}} with 72 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n    1339    C     ALA     A       95       95   14.815   -3.057   -5.633  1.00  0.00     1    PROT      1339\n    1340    O     ALA     A       95       95   14.862   -2.204   -6.518  1.00  0.00     1    PROT      1340\n\n\n\n\n\n","category":"function"},{"location":"readwrite/#PDBTools.read_mmcif","page":"Read and Write","title":"PDBTools.read_mmcif","text":"read_mmcif(mmCIF_file::String, selection::String; field_assignment)\nread_mmcif(mmCIF_file::String, selection_function::Function = all, field_assignment)\n\nread_mmcif(mmCIF_data::IOBuffer, selection::String; field_assignment)\nread_mmcif(mmCIF_data::IOBuffer, selection_function::Function = all, field_assignment)\n\nReads a mmCIF file and stores the data in a vector of type Atom. \n\nAll fields except the file name are optional.\n\nIf a selection is provided, only the atoms matching the selection will be read.  For example, resname ALA will select all the atoms in the residue ALA.\n\nIf a selection function is provided, only the atoms for which selection_function(atom) is true will be returned.\n\nThe field_assignment keyword is nothing (default) or a Dict{String,Symbol} and can be used to specify which fields in the mmCIF file should be read into the Atom type. For example field_assignment = Dict(\"type_symbol\" => :name) will read the _atom_site.type_symbol field in the mmCIF  file into the name field of the Atom type.\n\nThe default assignment is follows the standard mmCIF convention:\n\nDict{String,Symbol}(\n    \"id\" => :index_pdb\n    \"Cartn_x\" => :x\n    \"Cartn_y\" => :y\n    \"Cartn_z\" => :z\n    \"occupancy\" => :occup\n    \"B_iso_or_equiv\" => :beta\n    \"pdbx_formal_charge\" => :charge\n    \"pdbx_PDB_model_num\" => :model\n    \"label_atom_id\" => :name\n    \"label_comp_id\" => :resname\n    \"label_asym_id\" => :chain\n    \"auth_seq_id\" => :resnum\n    \"type_symbol\" => :pdb_element\n)\n\nSource: https://mmcif.wwpdb.org/docs/tutorials/content/atomic-description.html\n\nExamples\n\njulia> using PDBTools\n\njulia> ats = read_mmcif(PDBTools.TESTCIF)\n   Vector{Atom{Nothing}} with 76 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     GLY     A        1        1   -4.564   25.503   24.113  1.00 24.33     1                 1\n       2   CA     GLY     A        1        1   -4.990   26.813   24.706  1.00 24.29     1                 2\n⋮\n      75    O     HOH     Q       63       15   -3.585   34.725   20.903  1.00 19.82     1              2980\n      76    O     HOH     Q       64       16   -4.799   40.689   37.419  1.00 20.13     1              2981\n\njulia> ats = read_mmcif(PDBTools.TESTCIF, \"index < 3\")\n   Vector{Atom{Nothing}} with 2 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     GLY     A        1        1   -4.564   25.503   24.113  1.00 24.33     1                 1\n       2   CA     GLY     A        1        1   -4.990   26.813   24.706  1.00 24.29     1                 2\n\njulia> ats = read_mmcif(PDBTools.TESTCIF, at -> name(at) == \"CA\")\n   Vector{Atom{Nothing}} with 11 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       2   CA     GLY     A        1        1   -4.990   26.813   24.706  1.00 24.29     1                 2\n       6   CA     GLN     A        2        2   -4.738   30.402   23.484  1.00 23.74     1                 6\n⋮\n      70   CA      CA     G     1003       10  -24.170   27.201   64.364  1.00 27.40     1              2967\n      71   CA      CA     H     1004       11  -10.624   32.854   69.292  1.00 29.53     1              2968\n\n\n\n\n\n\n","category":"function"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"note: Note\nIn the following examples, the read_pdb function will be illustrated. The usage is similar to that of read_mmcif, to read mmCIF (PDBx) files. ","category":"page"},{"location":"readwrite/#Read-a-PDB/mmCIF-file","page":"Read and Write","title":"Read a PDB/mmCIF file","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"To read a PDB file and return a vector of atoms of type Atom, do:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"using PDBTools\natoms = read_pdb(PDBTools.test_dir*\"/structure.pdb\")","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"Atom{Nothing} is the default structure of data containing the atom index, name, residue, coordinates, etc. The Nothing refers to the content of the  custom atom fields. ","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"The data in the Atom structure is organized as indicated in the following documentation:","category":"page"},{"location":"readwrite/#PDBTools.Atom","page":"Read and Write","title":"PDBTools.Atom","text":"Atom::DataType\n\nStructure that contains the atom properties. It is mutable, so its fields can be modified.\n\nFields:\n\nmutable struct Atom{CustomType}\n    index::Int32 # The sequential index of the atoms in the file\n    index_pdb::Int32 # The index as written in the PDB file (might be anything)\n    name::String7 # Atom name\n    resname::String7 # Residue name\n    chain::String7 # Chain identifier\n    resnum::Int32 # Number of residue as written in PDB file\n    residue::Int32 # Sequential residue (molecule) number in file\n    x::Float32 # x coordinate\n    y::Float32 # y coordinate\n    z::Float32 # z coordinate\n    beta::Float32 # temperature factor\n    occup::Float32 # occupancy\n    model::Int32 # model number\n    segname::String7 # Segment name (cols 73:76)\n    pdb_element::String3 # Element symbol string (cols 77:78)\n    charge::Float32 # Charge (cols: 79:80)\n    custom::CustomType # Custom fields\n    flag::Int8 # Flag for internal use\nend\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB)\n   Vector{Atom{Nothing}} with 35 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2 1HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n      34    C     ASP     A        3        3   -2.626  -10.480   -7.749  1.00  0.00     1    PROT        34\n      35    O     ASP     A        3        3   -1.940  -10.014   -8.658  1.00  0.00     1    PROT        35\n\njulia> resname(atoms[1])\n\"ALA\"\n\njulia> chain(atoms[1])\n\"A\"\n\njulia> element(atoms[1])\n\"N\"\n\njulia> mass(atoms[1])\n14.0067f0\n\njulia> position(atoms[1])\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n  -9.229\n -14.861\n  -5.481\n\nThe pdb_element and charge fields, which are frequently left empty in PDB files, are not printed.  The direct access to the fields is considered part of the interface.\n\nCustom fields can be set on Atom construction with the custom keyword argument. The Atom structure will then be parameterized with the type of custom. \n\nExample\n\njulia> using PDBTools\n\njulia> atom = Atom(index = 0; custom=Dict(:c => \"c\", :index => 1));\n\njulia> typeof(atom)\nAtom{Dict{Symbol, Any}}\n\njulia> atom.custom\nDict{Symbol, Any} with 2 entries:\n  :index => 1\n  :c     => \"c\"\n\njulia> atom.custom[:c]\n\"c\"\n\n\n\n\n\n","category":"type"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"tip: Tip\nFor all these reading and writing functions, a final argument can be provided to read or write a subset of the atoms, following the selection syntax described  in the Selection section. For example:protein = read_pdb(\"file.pdb\",\"protein\")orarginines = read_pdb(\"file.pdb\",\"resname ARG\")Instead of the selection strings, a Julia function can be provided, for greater flexibility: arginines = read_pdb(\"file.pdb\", atom -> atom.resname == \"ARG\")The same is valid for the write function, below. ","category":"page"},{"location":"readwrite/#Write-a-PDB/mmCIF-file","page":"Read and Write","title":"Write a PDB/mmCIF file","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"To write a PDB file use the write_pdb function, as:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"write_pdb(\"file.pdb\", atoms)","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"where atoms contain a list of atoms with the Atom structures.","category":"page"},{"location":"readwrite/#PDBTools.write_pdb","page":"Read and Write","title":"PDBTools.write_pdb","text":"write_pdb(filename::String, atoms::AbstractVector{<:Atom}, [selection]; header=:auto, footer=:auto, append=false)\n\nWrite a PDB file with the atoms in atoms to filename. The selection argument is a string or function that can be used to select a subset of the atoms in atoms. For example, write_pdb(\"test.pdb\", atoms, \"name CA\").\n\nArguments\n\nfilename::String: The name of the file to write.\natoms::AbstractVector{<:Atom}: The atoms to write to the file.\n\nOptional positional argument\n\nselection::String: A selection string to select a subset of the atoms in atoms.\n\nKeyword arguments\n\nheader::Union{String, Nothing}=:auto: The header to add to the PDB file. If :auto, a header will be added with the number of atoms in atoms.\nfooter::Union{String, Nothing}=:auto: The footer to add to the PDB file. If :auto, a footer will be added with the \"END\" keyword.\nappend::Bool=false: If true, the atoms will be appended to the file instead of overwriting it.\n\n\n\n\n\n","category":"function"},{"location":"readwrite/#PDBTools.write_mmcif","page":"Read and Write","title":"PDBTools.write_mmcif","text":"write_mmcif(filename, atoms::AbstractVector{<:Atom}, [selection]; field_assignment=nothing)\n\nWrite a mmCIF file with the atoms in atoms to filename. The optional selection argument is a string or function that can be used to select a subset of the atoms in atoms. For example, write_mmcif(atoms, \"test.cif\", \"name CA\").\n\nThe optional field_assignment argument is a dictionary that can be used to assign custom fields to the mmCIF file.\n\n\n\n\n\n","category":"function"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"The use of the field_assignment keyword, as explained in the field assignment section is possible in the call to write_mmcif. ","category":"page"},{"location":"readwrite/#Get-structure-from-the-Protein-Data-Bank","page":"Read and Write","title":"Get structure from the Protein Data Bank","text":"","category":"section"},{"location":"readwrite/#PDBTools.wget","page":"Read and Write","title":"PDBTools.wget","text":"wget(PDBid; selection; format=\"mmCIF\")\n\nRetrieves a PDB file from the protein data bank. Selections may be applied.\n\nThe optional format argument can be either \"mmCIF\" or \"PDB\". The default is \"mmCIF\". To download the data of large structures, it is recommended to use the \"mmCIF\" format.\n\nExample\n\njulia> using PDBTools\n\njulia> protein = wget(\"1LBD\",\"chain A\")\n   Vector{Atom{Nothing}} with 1870 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     SER     A      225        1   45.228   84.358   70.638  1.00 67.05     1                 1\n       2   CA     SER     A      225        1   46.080   83.165   70.327  1.00 68.73     1                 2\n⋮\n    1869  CG2     THR     A      462      238  -27.063   71.965   49.222  1.00 78.62     1              1869\n    1870  OXT     THR     A      462      238  -25.379   71.816   51.613  1.00 84.35     1              1870\n\n\n\n\n\n\n","category":"function"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"Use the wget function to retrieve the atom data directly from the PDB database, optionally filtering the atoms with a selection:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"atoms = wget(\"1LBD\",\"name CA\")","category":"page"},{"location":"readwrite/#field_assignment","page":"Read and Write","title":"Atom field assignment in mmCIF files","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"By default, the assignment of the _atom_site fields of the mmCIF format to the fields of the Atom data structure  follows the standard mmCIF convention:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"Dict{String,Symbol}(\n    \"id\" => :index_pdb\n    \"Cartn_x\" => :x\n    \"Cartn_y\" => :y\n    \"Cartn_z\" => :z\n    \"occupancy\" => :occup\n    \"B_iso_or_equiv\" => :beta\n    \"pdbx_formal_charge\" => :charge\n    \"pdbx_PDB_model_num\" => :model\n    \"label_atom_id\" => :name\n    \"label_comp_id\" => :resname\n    \"label_asym_id\" => :chain\n    \"auth_seq_id\" => :resnum\n    \"type_symbol\" => :pdb_element\n)","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"This assignment can be customized by providing the field_assignment keyword parameter to the read_mmcif function.  In the following example, we exemplify the possibility of reading _atom_site.type_symbol field of the mmCIF file into the name field of the atom data structure:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"atoms = read_mmcif(PDBTools.test_dir*\"/small.cif\", \"index <= 5\");\nname.(atoms)","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"If, however, we attribute the name field to the type_symbol mmCIF field, which contains the element symbols, we get:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"atoms = read_mmcif(PDBTools.TESTCIF, \"index <= 5\"; \n   field_assignment=Dict(\"type_symbol\" => :name)\n)\nname.(atoms)","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"The custom entries set in the field_assignment keyword will overwrite the default  assignments for entries sharing keys or fields. For instance, in the example above, the label_atom_id fields which is by default assigned to :name is not being read anymore.","category":"page"},{"location":"readwrite/#Read-from-string-buffer","page":"Read and Write","title":"Read from string buffer","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"In some cases a PDB file data may be available as a string and not a regular file. For example, when reading the output of a zipped file. In these cases, it is possible to obtain the array of atoms by reading directly the string buffer with, for example:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"The following read returns a string with the PDB file data, not parsed, to exemplify:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"pdbdata = read(PDBTools.test_dir*\"/small.pdb\", String);","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"This string can be passed to the read_pdb function wrapped in a IOBuffer:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"atoms = read_pdb(IOBuffer(pdbdata), \"protein and name CA\")","category":"page"},{"location":"readwrite/#Edit-a-Vector{:Atom}-object","page":"Read and Write","title":"Edit a Vector{<:Atom} object","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"The Atom structure is mutable, meaning that the fields can be edited. For example:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB)\n   Vector{Atom{Nothing}} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  1.00  0.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  1.00  0.00     1    WAT2     62026\n\njulia> atoms[1].segname = \"ABCD\"\n\"ABCD\"\n\njulia> printatom(atoms[1])\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    ABCD         1","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"Additionally, With the edit! function, you can directly edit or view the data in a vector of Atoms in your preferred text editor. ","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> edit!(atoms)","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"This will open a text editor. Here, we modified the data in the resname field of the first atom to ABC. Saving and closing the file will update the atoms array:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> printatom(atoms[1])\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1    N     ABC     A        1        1   -9.229  -14.861   -5.481  0.00  1.00     1    PROT         1","category":"page"},{"location":"readwrite/#PDBTools.edit!","page":"Read and Write","title":"PDBTools.edit!","text":"edit!(atoms::AbstractVector{<:Atom})\n\nOpens a temporary PDB file in which the fields of the vector of atoms can be edited.   \n\n\n\n\n\n","category":"function"},{"location":"#PDBTools.jl","page":"Home","title":"PDBTools.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A lightweight and flexible Julia package for handling structure files with ease.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the Julia programming language, and do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"PDBTools\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using PDBTools\natoms = read_pdb(PDBTools.test_dir*\"/small.pdb\")","category":"page"},{"location":"#What-Makes-it-Special?","page":"Home","title":"What Makes it Special?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simple but Powerful: Read and write PDB and mmCIF structure files with minimal overhead. \nFlexible Atom Selection: Use intuitive syntax or custom Julia functions.\nPerfect for MD: Designed with molecular dynamics workflows in mind.\nLightweight: Focus on atomic data without the overhead of metadata parsing and compact data structures. Can handle very large structures.\nPerformance: Expect analysis functions to be fast. For instance, SASA and hydrogen bonds analyses are among the fastest available.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"#Clean-Data-Structure","page":"Home","title":"Clean Data Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Every atom is represented by a simple, accessible structure:","category":"page"},{"location":"","page":"Home","title":"Home","text":"atoms[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"(name(atoms[1]), resname(atoms[1]), chain(atoms[1]))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The use of InlineStrings makes the data structure compact, allowing handling millions of atoms is standard computers.","category":"page"},{"location":"#Intuitive-Selection-Syntax","page":"Home","title":"Intuitive Selection Syntax","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Select atoms using simple, readable syntax, similar to that of VMD:","category":"page"},{"location":"","page":"Home","title":"Home","text":"selection = select(atoms, \"resname ALA and name N CA\")","category":"page"},{"location":"#Power-of-Julia-Functions","page":"Home","title":"Power of Julia Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Leverage Julia's expressiveness for complex selections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"selection = select(atoms, atom -> \n    (atom.resname == \"ARG\" && atom.x < 10) || atom.name == \"N\"\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use of Julia functions for selection can also improve performance if dynamic selections are used in critical code.","category":"page"},{"location":"#See-also","page":"Home","title":"See also","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PDBTools.jl is integrated with MolSimToolkit.jl and ComplexMixtures.jl, providing novel and practical tools for molecular dynamics simulations analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nPDBTools prioritizes flexibility over strict format adherence. It's designed for:Molecular dynamics workflows\nQuick structure analysis\nBasic PDB/mmCIF file manipulationFor comprehensive PDB/mmCIF format support, check out BioStructures.jl from BioJulia.","category":"page"}]
}
