var documenterSearchIndex = {"docs":
[{"location":"help/#Help-entries","page":"Help entries","title":"Help entries","text":"","category":"section"},{"location":"help/","page":"Help entries","title":"Help entries","text":"The help entries for each function can be accessed from the Julia REPL by typing ?, for example,","category":"page"},{"location":"help/","page":"Help entries","title":"Help entries","text":"julia> ? mass\nsearch: mass mapslices MathConstants makedocs set_zero_subnormals get_zero_subnormals mutable struct\n\n  mass(name::String or atom::Atom or Vector{<:Atom})\n\n  Returns the mass of an atom given its name, or Atom structure, or the total mass of a vector of Atoms.\n\n  Example\n  –––––––––\n\n  julia> atoms = [ Atom(name=\"NT3\"), Atom(name=\"CA\") ];\n  \n  julia> mass(atoms[1])\n  14.0067\n  \n  julia> mass(\"CA\")\n  12.011\n  \n  julia> mass(atoms)\n  26.017699999999998\n","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Install the package using the package manager:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> ] add PDBTools\n","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"and load it with","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using PDBTools\n","category":"page"},{"location":"dihedrals/#Dihedrals-and-Ramachandran-plots","page":"Dihderals and Ramachandran","title":"Dihedrals and Ramachandran plots","text":"","category":"section"},{"location":"dihedrals/","page":"Dihderals and Ramachandran","title":"Dihderals and Ramachandran","text":"Dihderal angles can be computed with the dihedral function, and an application  of this function is the computation of Ramachandran plots. ","category":"page"},{"location":"dihedrals/#MolSimToolkitShared.dihedral","page":"Dihderals and Ramachandran","title":"MolSimToolkitShared.dihedral","text":"dihedral(at1::Atom, at2::Atom, at3::Atom, at4::Atom)\n\nComputes the dihderal angle given four atoms of type PDBTools.Atom.\n\nExample\n\njulia> using PDBTools\n\njulia> pdb = read_pdb(PDBTools.TESTPDB);\n\njulia> C1 = pdb[11]; N2 = pdb[13]; CA2 = pdb[15]; C2 = pdb[22];\n\njulia> phi = dihedral(C1, N2, CA2, C2) \n-36.70359f0\n\n\n\n\n\n","category":"function"},{"location":"dihedrals/#PDBTools.Ramachandran","page":"Dihderals and Ramachandran","title":"PDBTools.Ramachandran","text":"Ramachandran(prot::AbstractVector{<:PDBTools.Atom})\nRamachandran # type\n\nThe Ramachandran function receives a vector of atoms of a protein and and returns a Ramachandran object, with two fields phi and psi, containing the lists of corresponding angles, that is:\n\nphi: C(-1) - N - CA - C\npsi: N - CA - C - N(+1)\n\nIf any of the above atoms is missing, the function errors. The residues are expected to belong to a single chain and consecutive. \n\nThe resulting Ramachandran object can be plotted with the Plots.scatter function.\n\nExample\n\njulia> using PDBTools\n\njulia> prot = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> ram = Ramachandran(prot)\nRamachandran data: phi, psi vectors with 102 angles.\n\n\n\n\n\n\n","category":"type"},{"location":"dihedrals/#Plots.scatter-Tuple{Ramachandran}","page":"Dihderals and Ramachandran","title":"Plots.scatter","text":"scatter(ram::Ramachandran; kargs...)\n\nCreates a Ramachandran plot given a Ramachandran object.\n\nArguments\n\nram::Ramachandran: the Ramachandran object, containing ϕ and ψ angles,  resulting from the the Ramachandan function.\n\nAll other arguments are default keywords of Plots.scatter and can be adjusted to customize the plot.\n\nExample\n\njulia> using PDBTools, Plots\n\njulia> prot = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> ram = Ramachandran(prot)\nRamachandran data: phi, psi vectors with 102 angles.\n\njulia> # plt = scatter(map) # uncomment to plot\n\n\n\n\n\n","category":"method"},{"location":"dihedrals/#Dihedral-angles","page":"Dihderals and Ramachandran","title":"Dihedral angles","text":"","category":"section"},{"location":"dihedrals/","page":"Dihderals and Ramachandran","title":"Dihderals and Ramachandran","text":"The dihderal function computes the dihderal angle given four atoms:","category":"page"},{"location":"dihedrals/","page":"Dihderals and Ramachandran","title":"Dihderals and Ramachandran","text":"julia> using PDBTools\n\njulia> prot = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> dihedral(prot[1], prot[5], prot[11], prot[13])\n64.07296f0","category":"page"},{"location":"dihedrals/#Ramachandran-plot","page":"Dihderals and Ramachandran","title":"Ramachandran plot","text":"","category":"section"},{"location":"dihedrals/","page":"Dihderals and Ramachandran","title":"Dihderals and Ramachandran","text":"The Ramachandran function and object are used to compute and plot Ramachandran plots for a protein structure. The call to Ramachandran(vec) where vec is a vector of Atoms returns a Ramachandran object, with fields phi and psi, containing the list of dihedral angles:","category":"page"},{"location":"dihedrals/","page":"Dihderals and Ramachandran","title":"Dihderals and Ramachandran","text":"using PDBTools\nprot = read_pdb(PDBTools.TESTPDB, \"protein\");\nram = Ramachandran(prot)","category":"page"},{"location":"dihedrals/","page":"Dihderals and Ramachandran","title":"Dihderals and Ramachandran","text":"Given the ram::Ramachandran object, the scatter function from Plots can be used to  produce the Ramachandran plot:","category":"page"},{"location":"dihedrals/","page":"Dihderals and Ramachandran","title":"Dihderals and Ramachandran","text":"using Plots\nscatter(ram)","category":"page"},{"location":"dihedrals/","page":"Dihderals and Ramachandran","title":"Dihderals and Ramachandran","text":"All scatter parametes can be customized using the Plots keyword syntax. ","category":"page"},{"location":"auxiliary/#Some-auxiliary-functions-to-quickly-retrieve-some-data","page":"Auxiliary functions","title":"Some auxiliary functions to quickly retrieve some data","text":"","category":"section"},{"location":"auxiliary/#Get-the-protein-sequence","page":"Auxiliary functions","title":"Get the protein sequence","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"To obtain a list of the residue names of the protein with three- and one-letter codes, use","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> pdb = read_pdb(PDBTools.SMALLPDB);\n\njulia> getseq(pdb)\n3-element Vector{String}:\n \"A\"\n \"C\"\n \"D\"","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Use getseq(atoms,code=2) to get the sequence as three-letter residue codes, or code=3 to get  full natural-aminoacid names, like \"Alanine\", \"Proline\", etc:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> pdb = read_pdb(PDBTools.SMALLPDB);\n\njulia> getseq(pdb; code=2)\n3-element Vector{String}:\n \"ALA\"\n \"CYS\"\n \"ASP\"\n\njulia> getseq(pdb; code=3)\n3-element Vector{String}:\n \"Alanine\"\n \"Cysteine\"\n \"Aspartic acid\"","category":"page"},{"location":"auxiliary/#PDBTools.getseq","page":"Auxiliary functions","title":"PDBTools.getseq","text":"getseq(AbstractVector{<:Atom} or filename; selection, code)\n\nReturns the sequence of aminoacids from the vector of atoms or file name. Selections may be applied. Code defines if the output will be a one-letter, three-letter or full-residue name array.\n\nExample\n\njulia> using PDBTools\n\njulia> protein = read_pdb(PDBTools.TESTPDB);\n\njulia> getseq(protein, \"residue < 3\")\n2-element Vector{String}:\n \"A\"\n \"C\"\n\njulia> getseq(protein, \"residue < 3\"; code=2)\n2-element Vector{String}:\n \"ALA\"\n \"CYS\"\n\njulia> getseq(protein, \"residue < 3\"; code=3)\n2-element Vector{String}:\n \"Alanine\"\n \"Cysteine\"\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#PDBTools.Sequence","page":"Auxiliary functions","title":"PDBTools.Sequence","text":"Sequence\n\nWrapper for strings, or vectors of chars, strings, or residue names, to dispatch on  functions that operate on amino acid sequences.\n\nExample\n\njulia> seq = [\"Alanine\", \"Glutamic acid\", \"Glycine\"];\n\njulia> mass(Sequence(seq))\n257.2432\n\njulia> seq = \"AEG\";\n\njulia> mass(Sequence(seq))\n257.2432\n\n\n\n\n\n","category":"type"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"note: Note\nIf there is some non-standard protein residue in the sequence, inform the getseq function by adding a selection:julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> for at in atoms\n          if resname(at) == \"ALA\"\n              at.resname = \"NEW\"\n          end\n       end\n\njulia> getseq(atoms, \"protein or resname NEW\"; code=2)\n3-element Vector{String}:\n \"NEW\"\n \"CYS\"\n \"ASP\"By default the selection will only return the sequence of natural amino acids. ","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The getseq function can of course be used on an Atom list, accepts selections as the last argument, as well as the reading and writing functions:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> getseq(atoms, \"residue > 1\")\n2-element Vector{String}:\n \"C\"\n \"D\"","category":"page"},{"location":"auxiliary/#Distance-between-sets-of-atoms","page":"Auxiliary functions","title":"Distance between sets of atoms","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The distance between atoms, or sets of atoms, can be computed with the distance function. This function returns the minimum distance between the atoms of the sets involved. For example:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> model = wget(\"1BSX\");\n\njulia> protein = select(model,\"protein\");\n\njulia> ligand = select(model,\"resname T3\");\n\njulia> distance(protein,ligand)\n2.7775834820937417","category":"page"},{"location":"auxiliary/#PDBTools.distance","page":"Auxiliary functions","title":"PDBTools.distance","text":"distance(x,y)\n\nComputes the minimum distance between two sets of atoms, between an atom and a set of atoms, or simply  the distance between two atoms, or from the coordinates or sets of coordinates. \n\nThe input may be an Atom vector of Atoms, or a 3D vector, or a vector of 3D vector of coordinates, for examples as output by the coor function.\n\nExamples\n\njulia> model = wget(\"1BSX\");\n\njulia> protein = select(model,\"protein\");\n\njulia> ligand = select(model,\"resname T3\");\n\njulia> distance(protein,ligand)\n2.7775834820937417\n\njulia> distance(protein[1],ligand[3])\n36.453551075306784\n\njulia> distance(coor(ligand),protein)\n2.7775834820937417\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Closest-atoms-and-their-distance","page":"Auxiliary functions","title":"Closest atoms and their distance","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"A function similar to the one above is closest, which returns the shortest distance between atoms but also the identity of the atom or pair of atoms that satisfy that shortest distance:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> model = wget(\"1BSX\");\n\njulia> protein = select(model,\"protein\");\n\njulia> ligand = select(model,\"resname T3\");\n\njulia> closest(ligand,protein)\n(43, 3684, 2.7775834820937417)\n\njulia> ligand[43]\n    4037   O1      T3     B        2      512  -22.568   81.625    3.159  1.00 36.59     1       -      4041\n\njulia> protein[3684]\n    3684  NE2     HIS     B      435      472  -21.539   82.145    5.686  1.00 44.44     1       -      3686\n\njulia> distance(ligand[43],protein[3684])\n2.7775834820937417","category":"page"},{"location":"auxiliary/#PDBTools.closest","page":"Auxiliary functions","title":"PDBTools.closest","text":"closest(x,y)\n\nComputes the minimum distance between two sets of atoms and returns the indices of the atoms  and their distance. Both vector of atoms or vectors of coordinates can be used as input.\n\nExamples\n\njulia> model = wget(\"1BSX\");\n\njulia> protein = select(model,\"protein\");\n\njulia> ligand = select(model,\"resname T3\");\n\njulia> closest(ligand,protein)\n(43, 3684, 2.7775834820937417)\n\njulia> ligand[43]\n    4037   O1      T3     B        2      512  -22.568   81.625    3.159 36.59  1.00     1       -      4041\n\njulia> closest(ligand[43],protein)\n(1, 3684, 2.7775834820937417)\n\njulia> x = coor(protein)\n3994-element Vector{SVector{3, Float64}}:\n [52.884, 24.022, 35.587]\n [52.916, 24.598, 36.993]\n ⋮\n [-46.887, 86.925, 13.235]\n [-47.164, 83.593, 15.25]\n\njulia> closest(ligand,x)\n(43, 3684, 2.7775834820937417)\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Obtain-arrays-with-coordinates","page":"Auxiliary functions","title":"Obtain arrays with coordinates","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Use the coor function:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> coor(atoms[1])\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n  -9.229\n -14.861\n  -5.481\n\njulia> coor(atoms[1:2])\n2-element Vector{StaticArraysCore.SVector{3, Float32}}:\n [-9.229, -14.861, -5.481]\n [-10.048, -15.427, -5.569]","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The coor function accepts selections:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Calpha coordinates:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> coor(atoms, \"name CA\")\n3-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-8.483, -14.912, -6.726]\n [-5.113, -13.737, -5.466]\n [-3.903, -11.262, -8.062]","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The coordinates are output as arrays of static arrays (more specifically, as a Vector{SVector{3,Float64}}, from StaticArrays). ","category":"page"},{"location":"auxiliary/#PDBTools.coor","page":"Auxiliary functions","title":"PDBTools.coor","text":"coor(atoms; selection)\n\nReturns the coordinates of the atoms. The input may be one atom (type Atom), a vector of atoms, or a Residue.  The coordinates are returned as a vector of static vectors (from StaticArrays), more specifically as a Vector{SVector{3,Float64}}.\n\nExamples\n\njulia> using PDBTools, StaticArrays \n\njulia> protein = wget(\"1LBD\");\n\njulia> coor(protein[1])\n3-element SVector{3, Float64} with indices SOneTo(3):\n 45.228\n 84.358\n 70.638\n\njulia> coor(protein[1],as=SVector{3,Float32})\n3-element SVector{3, Float32} with indices SOneTo(3):\n 45.228\n 84.358\n 70.638\n\njulia> coor(protein, \"index <= 2\")\n2-element Vector{SVector{3, Float64}}:\n [45.228, 84.358, 70.638]\n [46.08, 83.165, 70.327]\n\njulia> coor(protein, at -> at.resname == \"ALA\")\n110-element Vector{SVector{3, Float64}}:\n [43.94, 81.982, 70.474]\n [43.02, 80.825, 70.455]\n [41.996, 80.878, 69.34]\n ⋮\n [-17.866, 84.088, 51.741]\n [-18.496, 83.942, 52.777]\n [-15.888, 82.583, 51.706]\n  \njulia> residues = collect(eachresidue(protein));\n\njulia> coor(residues[1])\n6-element Vector{SVector{3, Float64}}:\n [45.228, 84.358, 70.638]\n [46.08, 83.165, 70.327]\n [45.257, 81.872, 70.236]\n [45.823, 80.796, 69.974]\n [47.147, 82.98, 71.413]\n [46.541, 82.639, 72.662]\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Maximum-and-minimum-coordinates-of-the-atoms","page":"Auxiliary functions","title":"Maximum and minimum coordinates of the atoms","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Use maxmin(atoms), or maxmin(atoms,\"resname CA\"), for example:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> maxmin(atoms, \"residue > 1\")\n Minimum atom coordinates: xmin = [-6.974, -16.785, -10.863]\n Maximum atom coordinates: xmax = [-1.94, -9.552, -3.844]\n Length in each direction: xlength = [5.034000000000001, 7.2330000000000005, 7.019]","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"m is a structure containing the three vectors with minimum and maximum coordinates, and lengths.","category":"page"},{"location":"auxiliary/#PDBTools.maxmin","page":"Auxiliary functions","title":"PDBTools.maxmin","text":"maxmin(atoms::AbstractVector{<:Atom}; selection)\n\nReturns the maximum and minimum coordinates of an atom vector, and the length (maximum minus minimum) in each direction. \n\nExample\n\njulia> protein = wget(\"1LBD\");\n\njulia> maxmin(protein)\n \n Minimum atom coordinates: xmin = [-29.301, 57.178, 45.668]\n Maximum atom coordinates: xmax = [47.147, 99.383, 86.886]\n Length in each direction: xlength = [76.448, 42.205, 41.217999999999996]\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Residue-tick-labels-for-plots","page":"Auxiliary functions","title":"Residue tick labels for plots","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The residue_ticks function provides a practical way to define tick labels in plots associated to an amino-acid sequence:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"residue_ticks(\n    atoms (or) residues (or) residue iterator; \n    first=nothing, last=nothing, stride=1, oneletter=true, serial=false,\n)","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The input structure can be provided as a vector of atoms (type Vector{<:Atom}) a residue iterator (obtained by eachresidue(atoms)) or a vector of residues (obtained by collect(eachresidue(atoms))). ","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"The function returns a tuple with residue numbers and residue names for the given atoms, to be used as tick labels in plots.","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"first and last optional keyword parameters are integers that refer to the residue numbers to be included.  The stride option can be used to skip residues and declutter the tick labels.","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"If oneletter is false, three-letter residue codes are returned. Residues with unknown names will be  named X or XXX. ","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"if serial=false the positions of the ticks will be returned as a the serial residue index in the structure. If serial=true the positions of the ticks are returned as their residue numbers. This difference is important if the residue numbers do not start at 1 and depending on the indexing of the data to be plotted.  ","category":"page"},{"location":"auxiliary/#PDBTools.residue_ticks","page":"Auxiliary functions","title":"PDBTools.residue_ticks","text":"residue_ticks(\n    atoms (or) residues (or) residue iterator; \n    first=nothing, last=nothing, stride=1, oneletter=true, serial=false\n)\n\nReturns a tuple with residue numbers and residue names for the given atoms, to be used as tick labels in plots.\n\nThe structure data can be provided a vector of Atoms, a vector of Residues or an eachresidue iterator. \n\nfirst and last optional keyword parameters are integers that refer to the residue numbers to be included.  The stride option can be used to skip residues and declutter the tick labels.\n\nIf oneletter is false, three-letter residue codes are returned. Residues with unknown names will be  named X or XXX. \n\nIf serial=true the sequential residue index will be used as the index of the ticks. If instead serial=false, the positions will be set to the residue numbers.\n\nExamples\n\njulia> using PDBTools\n\njulia> atoms = wget(\"1LBD\", \"protein\");\n\njulia> residue_ticks(atoms; stride=50) # Vector{<:Atom} as input\n(Int32[225, 275, 325, 375, 425], [\"S225\", \"Q275\", \"L325\", \"L375\", \"L425\"])\n\njulia> residue_ticks(atoms; first=235, last=240) # first=10\n(Int32[235, 236, 237, 238, 239, 240], [\"I235\", \"L236\", \"E237\", \"A238\", \"E239\", \"L240\"])\n\njulia> residue_ticks(eachresidue(atoms); stride=50) # residue iterator as input\n(Int32[225, 275, 325, 375, 425], [\"S225\", \"Q275\", \"L325\", \"L375\", \"L425\"])\n\njulia> residue_ticks(collect(eachresidue(atoms)); stride=50) # Vector{Residue} as input\n(Int32[225, 275, 325, 375, 425], [\"S225\", \"Q275\", \"L325\", \"L375\", \"L425\"])\n\njulia> residue_ticks(atoms; first=10, stride=50, serial=true) # using serial=true\n(10:50:210, [\"R234\", \"K284\", \"R334\", \"S384\", \"E434\"])\n\n\nThe resulting tuple of residue numbers and labels can be used as xticks in Plots.plot, for example.\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#PDBTools.oneletter","page":"Auxiliary functions","title":"PDBTools.oneletter","text":"oneletter(residue::Union{AbstractString,Char})\n\nFunction to return a one-letter residue code from the three letter code or residue name. The function is case-insensitive.\n\nExamples\n\njulia> oneletter(\"ALA\")\n\"A\"\n\njulia> oneletter(\"Glutamic acid\")\n\"E\"\n\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#PDBTools.threeletter","page":"Auxiliary functions","title":"PDBTools.threeletter","text":"threeletter(residue::String)\n\nFunction to return the three-letter natural-amino acid residue code from the one-letter  code or residue name. The function is case-insensitive.\n\nExamples\n\njulia> threeletter(\"A\")\n\"ALA\"\n\njulia> threeletter(\"Aspartic acid\")\n\"ASP\"\n\njulia> threeletter(\"HSD\")\n\"HIS\"\n\n\n\n\n\n","category":"function"},{"location":"auxiliary/#Example","page":"Auxiliary functions","title":"Example","text":"","category":"section"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Here we illustrate how to plot the average temperature factor of each residue of a crystallographic model as function of the residues.","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> using PDBTools, Plots\n\njulia> atoms = wget(\"1UBQ\", \"protein\");\n\njulia> residue_ticks(atoms; stride=10) # example of output\n([1, 11, 21, 31, 41, 51, 61, 71], [\"M1\", \"K11\", \"D21\", \"Q31\", \"Q41\", \"E51\", \"I61\", \"L71\"])\n\njulia> plot(\n           resnum.(eachresidue(atoms)), # x-axis: residue numbers\n           [ mean(beta.(res)) for res in eachresidue(atoms) ], # y-axis: average b-factor per residue\n           xlabel=\"Residue\", \n           xticks=residue_ticks(atoms; stride=10), # here we define the x-tick labels\n           ylabel=\"b-factor\", \n           xrotation=60,\n           label=nothing, framestyle=:box,\n      )","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Produces the following plot:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"(Image: ./assets/residue_ticks.png)","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Alternatively (and sometimes conveniently), the residue ticks can be obtained by providing,  instead of the atoms array, the residue iterator or the residue vector, as:","category":"page"},{"location":"auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"julia> residue_ticks(eachresidue(atoms); stride=10)\n([1, 11, 21, 31, 41, 51, 61, 71], [\"M1\", \"K11\", \"D21\", \"Q31\", \"Q41\", \"E51\", \"I61\", \"L71\"])\n\njulia> residue_ticks(collect(eachresidue(atoms)); stride=10)\n([1, 11, 21, 31, 41, 51, 61, 71], [\"M1\", \"K11\", \"D21\", \"Q31\", \"Q41\", \"E51\", \"I61\", \"L71\"])","category":"page"},{"location":"contacts/#Contact-and-distance-maps","page":"Contact maps","title":"Contact and distance maps","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"The contact_map function computes a contact map for a structure or a pair of structures. These structures are typically proteins, but any structures defined by sequences of residues can be provided as inputs. The heatmap function, from Plots, is overloaded here to provide a convenient way to plot the contact or distance maps.","category":"page"},{"location":"contacts/#PDBTools.contact_map","page":"Contact maps","title":"PDBTools.contact_map","text":"contact_map(\n    atoms1::AbstractVector{<:PDBTools.Atom}\n    atoms2::AbstractVector{<:PDBTools.Atom}; # optional for contacts between two structures\n    dmax::Real=4.0,\n    gap::Int=0, # only available if atoms2 is not provided\n    unitcell=nothing,\n    discrete::Bool=true,\n    positions::Union{Nothing,AbstractVector{<:AbstractVector{<:Real}}}=nothing,\n)\n\nCalculate the contact map between residues in a protein* structure (if only  atoms1 is provided) or between residues in two different protein* structures (atoms1 and atoms2). \n\nnote: Note\nThe distance used to define a contact is the minimum distance between any two atoms of the residues of the atoms groups provided, with a  threshold distance dmax.\n\nReturns the contact map as a ContactMap object.\n\n*The term \"protein\" is used here to refer to any structure with residues.\n\nArguments\n\natoms1::AbstractVector{<:PDBTools.Atom}: Atoms of the first structure.\natoms2::AbstractVector{<:PDBTools.Atom}: Atoms of the second structure, if provided. \n\nOptional keyword arguments\n\ndmax::Real=4.0: Threshold distance for a contact.\ngap::Int=0: Gap between residues to calculate contacts.\nunitcell=nothing: Unit cell dimensions for periodic boundary conditions.\ndiscrete::Bool=true: If true, the matrix contains Bool values, where true  indicates a contact and false indicates no contact.  If false, the matrix contains distances between residues.\npositions: Positions of the atoms in the structure. If provided, the function uses these  positions to calculate the distance between residues.\n\nExamples\n\nContact map between residues in the same structure\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> cA = select(ats, \"chain A\");\n\njulia> cB = select(ats, \"chain B\");\n\njulia> map = contact_map(cA, cB) # contact map between chains A and B\nContactMap{Union{Missing, Bool}} of size (243, 12), with threshold 4.0 and gap 0 \n\njulia> # using Plots; heatmap(map); # uncoment to plot the contact map\n\nContact map between residues in two different structures\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> cA = select(ats, \"chain A\");\n\njulia> cB = select(ats, \"chain B\");\n\njulia> map = contact_map(cA, cB) # contact map between chains A and B\nContactMap{Union{Missing, Bool}} of size (243, 12), with threshold 4.0 and gap 0 \n\njulia> # using Plots; heatmap(map); # uncoment plot the contact map\n\n\n\n\n\n","category":"function"},{"location":"contacts/#Plots.heatmap-Tuple{ContactMap}","page":"Contact maps","title":"Plots.heatmap","text":"heatmap(map::PDBTools.ContactMap; kwargs...)\n\nPlot a contact map.\n\nArguments\n\nmap::ContactMap: the contact map to plot\n\nAll other arguments are default keywords of Plots.heatmap and can be adjusted to customize the plot.\n\nMost typical options to adjust are:\n\nxstep: the stride of the x-axis ticks \nystep: the stride of the y-axis ticks\ncolor: the color palette to use (default: :grayC for distances, :Greys_9 for binary maps)\nclims: the range of the color scale.\ncolorbar_title: the title of the colorbar. Default: \"distance (Å)\" for distances, no title for binary maps.\n\nExample\n\njulia> using PDBTools, Plots\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> cA = select(ats, \"chain A\");\n\njulia> cB = select(ats, \"chain B\");\n\njulia> map = contact_map(cA, cB)\nContactMap{Union{Missing, Bool}} of size (243, 12), with threshold 4.0 and gap 0\n\njulia> # plt = heatmap(map) # uncomment to plot\n\njulia> map = contact_map(cA, cB; discrete=false) # distance map\nContactMap{Union{Missing, Float32}} of size (243, 12), with threshold 4.0 and gap 0\n\njulia> # plt = heatmap(map) # uncomment to plot\n\n\n\n\n\n","category":"method"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"note: Note\nThe distance computed in these functions is the minimum distance between the  atoms of the residues. If, for example, a contact map computed from the distance between Cα atoms is desired, select the atoms before computing the map:cA = select(\"chain A and name CA\")\ncontact_map(cA; dmax=8.0)Importantly, the maximum distance defining a contact has to be adjusted, as it is, by default, dmax=4.0, which is a reasonable contact measure from minimum distance between atoms, but too short for distances between backbone atoms.","category":"page"},{"location":"contacts/#Contact-map","page":"Contact maps","title":"Contact map","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"A typical usage consists in computing the contact map and plotting it:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"using PDBTools\nusing Plots\nats = read_pdb(PDBTools.DIMERPDB);\ncA = select(ats, \"chain A\");\ncB = select(ats, \"chain B\");\nmap = contact_map(cA, cB) # contact map between chains A and B\nheatmap(map)","category":"page"},{"location":"contacts/#Distance-map","page":"Contact maps","title":"Distance map","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"In the example above we opted to plot a discrete contact map, with the default contact  distance dmax=4.0. Now we change two parameters: discrete=false and dmax=12.0, to compute a distance map up to a greater distance:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"using PDBTools\nusing Plots\nats = read_pdb(PDBTools.DIMERPDB);\ncA = select(ats, \"chain A\");\ncB = select(ats, \"chain B\");\nmap = contact_map(cA, cB; discrete=false, dmax=12.0) # contact map between chains A and B\nheatmap(map)","category":"page"},{"location":"contacts/#Single-structure","page":"Contact maps","title":"Single structure","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"Similarly, we can produce plots for the contact map of a single structure. Here, we  showcase the use of the gap parameter, to ignore residues closer in the sequence by less than 4 residues:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"using PDBTools\nusing Plots\nats = read_pdb(PDBTools.DIMERPDB);\ncA = select(ats, \"chain A\");\ndistance_map = contact_map(cA; gap=4, discrete=false, dmax=12.0) # chain A only\ndiscrete_map = contact_map(cA; gap=4, discrete=true, dmax=12.0) # chain A only\nplot(\n    heatmap(distance_map; colorbar=nothing, color=:davos), \n    heatmap(discrete_map); \n    layout=(1,2), size=(800,500)\n)","category":"page"},{"location":"contacts/#Customizing-the-plot","page":"Contact maps","title":"Customizing the plot","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"All heatmap parametes can be customized using the Plots keyword syntax. Above,  we illustrated this by removing the color bar and changing the color scale. ","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"Common customization options are:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"xstep: the stride of the x-axis ticks \nystep: the stride of the y-axis ticks\ncolor: the color palette to use (default: :grayC for distances, :Greys_9 for binary maps)\nclims: the range of the color scale.\ncolorbar_title: the title of the colorbar. Default: \"distance (Å)\" for distances, no title for binary maps.","category":"page"},{"location":"contacts/#Indexing","page":"Contact maps","title":"Indexing","text":"","category":"section"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"The ContactMap data structure can be indexed to extract the contacts of a specific  residue. For example:","category":"page"},{"location":"contacts/","page":"Contact maps","title":"Contact maps","text":"using PDBTools\nats = read_pdb(PDBTools.DIMERPDB);\ncA = select(ats, \"chain A\");\ncB = select(ats, \"chain B\");\nmap = contact_map(cA, cB; discrete=false, dmax=12.0)\nmap[235,:] # all distances below 12.0 Angs of residue 235 of cA with cB","category":"page"},{"location":"contacts/#Data-structure-and-auxiliary-functions","page":"Contact maps","title":"Data structure and auxiliary functions","text":"","category":"section"},{"location":"contacts/#PDBTools.ContactMap","page":"Contact maps","title":"PDBTools.ContactMap","text":"ContactMap{Bool|Real}\n\nData structure to store contact maps between residues in a protein structure. The contact map is a matrix of distances between residues. A contact is defined  when the distance between any two atoms of the residues is less than a given threshold dmax.\n\nIf the distance between two residues is greater than dmax, the value in the matrix is missing, indicating that there is no contact between the residues. If the distance is less than dmax, the value in the matrix is the distance between the residues.\n\nThe gap parameter is used to calculate contacts between residues separated by a given number of residues. For example, if gap=3, the contact map was  calculated between residues separated by at least 3 residues in the sequence.\n\nFields\n\nmatrix::Matrix{Union{Missing,T}}: Matrix of distances between residues.\nd::T: Threshold distance for a contact.\ngap::Int: Gap between residues to calculate contacts.\n\nIf the contact map was calculated with discrete=true, the matrix contains Bool values, where true indicates a contact and false indicates no contact. On the other hand, if discrete=false, the matrix contains distances between residues.\n\n\n\n\n\n","category":"type"},{"location":"contacts/#PDBTools.residue_residue_distance","page":"Contact maps","title":"PDBTools.residue_residue_distance","text":"residue_residue_distance(\n    r1::PDBTools.Residue, \n    r2::PDBTools.Residue; \n    positions::AbstractVector{AbstractVector{T}}=nothing; \n    unitcell=nothing\n)\n\nCalculate the minimum distance between two residues in a protein structure.  If the positions argument is not provided, the function calculates the distance using the coordinates of the atoms in the residues. If positions is provided, the function uses the coordinates in the positions array. \n\nArguments\n\nr1::PDBTools.Residue: Residue 1\nr2::PDBTools.Residue: Residue 2\npositions::AbstractVector{AbstractVector{T}}: Optional alternate positions of the atoms in the structure.\nunitcell=nothing: Optional unit cell dimensions for periodic boundary conditions.\n\nnote: Note\nThe index of the atoms in the residues must match the index of the atoms in the positions array. \n\nExample\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> residues = collect(eachresidue(ats));\n\njulia> r1 = residues[1]; r10 = residues[10];\n\njulia> println(name(r1), resnum(r1), \" and \", name(r10), resnum(r10))\nLYS211 and GLU220\n\njulia> d = residue_residue_distance(r1, r10)\n16.16511f0\n\n\n\n\n\n","category":"function"},{"location":"selections/#selections","page":"Selections","title":"Selection functions","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"The select function can be used to select subsets of atoms from a vector of atoms. A simple selection syntax can be used, for example: ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"atoms = select(atoms, \"protein and resnum < 30\")","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"or standard Julia function can be provided as the second argument:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"atoms = select(atoms, at -> isprotein(at) && resnum(at) < 30)","category":"page"},{"location":"selections/#PDBTools.select","page":"Selections","title":"PDBTools.select","text":"select(atoms::AbstractVector{<:Atom}, selection_string::String)\nselect(atoms::AbstractVector{<:Atom}, selection_function::Function)\n\nSelects atoms from a vector of atoms using a string query, or a function.\n\nThe string query can be a simple selection like \"name CA\" or a more complex one like \"name CA or (residue 1 2 3)\". The function can be any function that takes an atom and returns a boolean value.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> select(atoms, \"name CA and (residue > 1 and residue < 3)\")\n   Vector{Atom{Nothing}} with 1 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n      15   CA     CYS     A        2        2   -5.113  -13.737   -5.466  1.00  0.00     1    PROT        15\n\njulia> select(atoms, at -> name(at) == \"CA\" && 1 < residue(at) < 3)\n   Vector{Atom{Nothing}} with 1 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n      15   CA     CYS     A        2        2   -5.113  -13.737   -5.466  1.00  0.00     1    PROT        15  \n\n\n\n\n\n\n","category":"function"},{"location":"selections/#PDBTools.Select","page":"Selections","title":"PDBTools.Select","text":"Select\n\nThis structure acts a function when used within typical julia filtering functions,  by converting a string selection into a call to query call. \n\nExample\n\nUsing a string to select the CA atoms of the first residue:\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein\");\n\njulia> findfirst(Select(\"name CA\"), atoms)\n5\n\njulia> filter(Select(\"name CA and residue 1\"), atoms)\n   Vector{Atom{Nothing}} with 1 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       5   CA     ALA     A        1        1   -8.483  -14.912   -6.726  1.00  0.00     1    PROT         5\n\n\n\n\n\n\n","category":"type"},{"location":"selections/#General-selection-syntax","page":"Selections","title":"General selection syntax","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"Accepted Boolean operators: and, or, and not. \nAccepted comparison operators: <, >, <=, =>, ==\nSupport for parenthesis. \nSupport for multiple keys as a shorcut for multiple or (i. e. residue 1 3 5)","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"compat: Compat\nSupport for selection strings supporting parenthesis and multiple keys was introduced in v3.1.0\nSupport for selection by coordinates, x, y, and z was introduced in v3.2.0","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The accepted keywords for the selection are: ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Keyword Options Input value Example\nindex =,>,<,<=,>= Integer index <= 10\nindex_pdb =,>,<,<=,>= Integer index_pdb <= 10\nname  String name CA\nelement  String element N\nresname  String resname ALA\nresnum =,>,<,<=,>= Integer resnum = 10\nresidue =,>,<,<=,>= Integer residue = 10\nchain  String chain A\nmodel  Integer model 1\nbeta =,>,<,<=,>= Real beta > 0.5\noccup =,>,<,<=,>= Real occup >= 0.3\nsegname  String segname PROT\nx =,>,<,<=,>= Real x >= 3.0\ny =,>,<,<=,>= Real y < 0.0\nz =,>,<,<=,>= Real z >= 1.0\n   ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"note: Note\nresnum is the residue number as written in the PDB file, while residue is the residue number counted sequentially in the file.index_pdb is the number written in the \"atom index\" field of the PDB file, while index is the sequential index of the atom in the file. ","category":"page"},{"location":"selections/#Special-macros:-proteins,-water","page":"Selections","title":"Special macros: proteins, water","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"Just use these keywords to select the residues matching the properties desired. ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Examples:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"aromatic = select(atoms,\"aromatic\")\n","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"aromatic = select(atoms,\"charged\")\n","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Available keywords:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Keywords  \nwater  \nprotein backbone sidechain\nacidic basic \naliphatic aromatic \ncharged neutral \npolar nonpolar \nhydrophobic  \n  ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"note: Note\nThe properties refer to protein residues and will return false to every non-protein residue. Thus, be careful with the use of not with these selections, as they might retrieve non-protein atoms.","category":"page"},{"location":"selections/#Retrieving-indices,-filtering,-etc","page":"Selections","title":"Retrieving indices, filtering, etc","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"If only the indices of the atoms are of interest, the Julia findall function can be used, by passing a Select object, or a regular  function, to select the atoms:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and residue <= 3\");\n\njulia> findall(Select(\"name CA\"), atoms)\n3-element Vector{Int64}:\n  5\n 15\n 26\n\njulia> findall(at -> name(at) == \"CA\", atoms)\n3-element Vector{Int64}:\n  5\n 15\n 26","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"note: Note\nAll indexing is 1-based. Thus, the first atom of the structure is atom 1.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The Select constructor can be used to feed simple selection syntax entries to  other Julia functions, such as findfirst, findlast, or filter:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and residue <= 3\");\n\njulia> filter(Select(\"name CA\"), atoms)\n   Vector{Atom{Nothing}} with 3 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       5   CA     ALA     A        1        1   -8.483  -14.912   -6.726  1.00  0.00     1    PROT         5\n      15   CA     CYS     A        2        2   -5.113  -13.737   -5.466  1.00  0.00     1    PROT        15\n      26   CA     ASP     A        3        3   -3.903  -11.262   -8.062  1.00  0.00     1    PROT        26\n\njulia> findfirst(Select(\"beta = 0.00\"), atoms)\n1","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"tip: Tip\nThe sel\"\" literal string macro is a shortcut for Select. Thus, these syntaxes are valid:julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and residue <= 3\");\n\njulia> name.(filter(sel\"name CA\", atoms))\n3-element Vector{InlineStrings.String7}:\n \"CA\"\n \"CA\"\n \"CA\"\n\njulia> findfirst(sel\"name CA\", atoms)\n5","category":"page"},{"location":"selections/#Use-Julia-functions-directly","page":"Selections","title":"Use Julia functions directly","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"Selections can be done using Julia functions directly, providing a greater control over the selection and, possibly, the use of user defined selection  functions. For example:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"myselection(atom) = (atom.x < 10.0 && atom.resname == \"GLY\") || (atom.name == \"CA\") \natoms = select(atoms, myselection)","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"or, for example, using Julia anonymous functions","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"select(atoms, at -> isprotein(at) && name(at) == \"O\" && atom.x < 10.0)","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The only requirement is that the function defining the selection receives an PDBTools.Atom as input, and returns true or false depending on the conditions required for the atom.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"note: Note\nThe macro-keywords described in the previous section can be used within  the Julia function syntax, but the function names start with is. For example:select(atoms, at -> isprotein(at) && resnum(at) in [ 1, 5, 7 ])Thus, the macro selection functions are: iswater,  isprotein,     isbackbone,    issidechain, isacidic,      isbasic,                   isaliphatic,   isaromatic,                ischarged,     isneutral,                 ispolar,       isnonpolar,                and ishydrophobic.                          ","category":"page"},{"location":"selections/#Using-VMD","page":"Selections","title":"Using VMD","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"VMD is a very popular and powerful package for visualization of simulations. It contains a very versatile library to read topologies and trajectory files, and a powerful selection syntax. We provide here a wrapper to VMD which enables using its capabilities.  ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"warning: Warning\nSome notable differences of the PDBTools.select function relative to the selection syntax of VMD are:VMD uses 0-based indexing. Thus, the first atom is atom 0 for VMD, and  atom 1 for PDBTools. Same for residue numbering. Be careful.\nVMD uses resid for the residue number as written in the PDB file, while PDBTools uses residue. \nVMD uses residue for the sequential number of the residue in the  PDB file, while PDBTools uses resnum.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The select_with_vmd input can be a vector of PDBTools.Atoms, or a filename. If the input is a vector of Atoms, the output will be the corresponding atoms matching the selection. If the input is a filename, two lists are returned: the list of indices and names of the corresponding atoms. This is because some input files supported by VMD (e. g. GRO, PSF, etc.) do not contain full atom information. ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"For example, here some atoms are selected from a previously loaded vector of atoms:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"julia> using PDBTools\n\njulia> pdbfile = PDBTools.SMALLPDB\n\njulia> atoms = read_pdb(pdbfile);\n\njulia> selected_atoms = select_with_vmd(atoms,\"resname ALA and name HT2 HT3\";vmd=\"/usr/bin/vmd\")\n   Vector{Atom{Nothing}} with 2 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       3  HT2     ALA     A        1        1   -9.488  -13.913   -5.295  0.00  0.00     1    PROT         3\n       4  HT3     ALA     A        1        1   -8.652  -15.208   -4.741  0.00  0.00     1    PROT         4","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"And, now, we provide the filename as input:","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"julia> selected_atoms = select_with_vmd(pdbfile,\"resname ALA and name HT2 HT3\";vmd=\"/usr/bin/vmd\")\n([3, 4], [\"HT2\", \"HT3\"])","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Note that in the above examples we use name HT2 HT3 which is not currently supported by the  internal PDBTools select function, which would require name HT2 or name HT3. ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Here, the output will contain two lists, one of atom indices (one-based) and atom names. The indices correspond to sequential indices in the input, not the indices written in the PDB file, for example.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"tip: Tip\nIf vmd is available in your path, there is no need to pass it as a keyword parameter.","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"The main advantage here is that all the file types and the complete selection syntax  that VMD supports are supported. But VMD needs to be installed and is run in background, and it takes a few seconds to run.","category":"page"},{"location":"selections/#PDBTools.select_with_vmd","page":"Selections","title":"PDBTools.select_with_vmd","text":"select_with_vmd(atoms::AbstractVector{<:Atom}, selection::String; vmd=\"vmd\", srcload=nothing)\nselect_with_vmd(inputfile::String, selection::String; vmd=\"vmd\", srcload=nothing)\n\nSelect atoms using vmd selection syntax, with vmd in background. The input can be a file or a list of atoms.\n\nInput structure and output format:\n\natoms::AbstractVector{<:Atom}: A vector of PDBTools.Atom objects to select from. In this case, the output will be a vector of PDBTools.Atom objects that match the selection.\ninputfile::String: Path to the input file (e.g., PDB, PSF, GRO, etc.) or a temporary file containing atom data. In this case, two vectors will be returned: one with the indices of the selected atoms and another with their names.\n\nThe outputs are different in each case because VMD supports selections on files like PSF, GRO, etc., which do not  carry the full atom information like PDB files do.\n\nAdditional arguments:\n\nselection::String: A string containing the selection criteria in VMD syntax, e.g., \"protein and residue 1\".\nvmd::String: The command to run VMD. Default is \"vmd\", but can be set to the full path if VMD is not in the system PATH.\nsrcload::Union{Nothing, AbstractString, Vector{AbstractString}}: A script or a list of VMD scripts to load before executing the selection, for example with macros to define custom selection keywords.\n\nwarning: Warning\nVMD uses 0-based indexing, be careful to account for this when using indices in the selection string. If you want to suppress this warning, set index_warning=false in the function call.\n\n\n\n\n\n","category":"function"},{"location":"selections/#Loading-vmd-scripts","page":"Selections","title":"Loading vmd scripts","text":"","category":"section"},{"location":"selections/","page":"Selections","title":"Selections","text":"The select_with_vmd function also accepts an optional keyword parameter srcload, which can be used to load custom scripts within vmd before running setting the selection. This enables the definition of tcl scripts with custom selection macros, for instance. The usage would be: ","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"sel = select_with_vmd(\"file.pdb\", \"resname MYRES\"; srcload = [ \"mymacros1.tcl\", \"mymacros2.tcl\" ])","category":"page"},{"location":"selections/","page":"Selections","title":"Selections","text":"Which corresponds to sourceing each of the macro files in VMD before defining the  selection with the custom MYRES name.","category":"page"},{"location":"elements/#Atomic-and-molecular-properties","page":"Atom and element properties","title":"Atomic and molecular properties","text":"","category":"section"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"Some simple atom properties can be retrieved using special functions, which operate on atoms of the type Atom. For example:","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"julia> atoms = read_pdb(\"./file.pdb\");\n\njulia> printatom(atoms[1])\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1   OW     SOL     X        1        1   54.370   45.310   33.970  0.00  0.00     1       -         1\n\njulia> mass(atoms[1])\n14.0067\n\njulia> atomic_number(atoms[1])\n7\n\njulia> element(atoms[1])\n\"N\"\n\njulia> element_name(atoms[1])\n\"Nitrogen\"","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"The formula or stoichiometry of a selection can also be retrieved:","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"julia> atoms = wget(\"1LBD\",\"protein and residue 1\");\n\njulia> f = formula(atoms)\nC₃N₁O₂\n\njulia> stoichiometry(select(atoms,\"water\"))\nH₂O₁\n","category":"page"},{"location":"elements/#PDBTools.mass","page":"Atom and element properties","title":"PDBTools.mass","text":"mass(s::Sequence)\n\nReturns the mass of a sequence of amino acids, given a Sequence struct type.\n\nExamples\n\njulia> seq = [\"Alanine\", \"Glutamic acid\", \"Glycine\"];\n\njulia> mass(Sequence(seq))\n257.2432\n\njulia> seq = \"AEG\";\n\njulia> mass(Sequence(seq))\n257.2432\n\njulia> seq = [\"ALA\", \"GLU\", \"GLY\"];\n\njulia> mass(Sequence(seq))\n257.2432\n\n\n\n\n\nmass(atom::Atom)\nmass(atoms::AbstractVector{<:Atoms})\n\nReturns the mass of an atom given its name, or Atom structure, or the total mass of a vector of Atoms. \n\nIf a mass is defined as a custom field in the the Atom structure, it is returned. Otherwise, the mass is retrieved from the element mass as inferred from the atom name.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = [ Atom(name=\"NT3\"), Atom(name=\"CA\") ];\n\njulia> mass(atoms[1])\n14.0067f0\n\njulia> mass(atoms)\n26.0177f0\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element","page":"Atom and element properties","title":"PDBTools.element","text":"element(atom::Atom)\n\nReturns the element symbol, as a string, of an atom given the Atom structure. If the pdb_element is empty or \"X\", the element is inferred from the atom name.  Othwerwise, the pdb_element is returned.\n\nExample\n\njulia> using PDBTools\n\njulia> at = Atom(name=\"NT3\");\n\njulia> element(at)\n\"N\"\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element_name","page":"Atom and element properties","title":"PDBTools.element_name","text":"element_name(atom::Atom)\n\nReturns the element name of an atom given its name, or Atom structure.\n\nExample\n\njulia> using PDBTools\n\njulia> at = Atom(name=\"NT3\");\n\njulia> element_name(at)\n\"Nitrogen\"\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element_symbol","page":"Atom and element properties","title":"PDBTools.element_symbol","text":"element_symbol(atom::Atom)\n\nReturns a symbol for element name of an atom given its name, or Atom structure.\n\nExample\n\njulia> using PDBTools \n\njulia> at = Atom(name=\"NT3\");\n\njulia> element_symbol(at)\n:N\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element_symbol_string","page":"Atom and element properties","title":"PDBTools.element_symbol_string","text":"element_symbol_string(atom::Atom)\n\nReturns a string with the symbol of the element, given the Atom structure.\n\nExample\n\njulia> using PDBTools \n\njulia> at = Atom(name=\"NT3\");\n\njulia> element_symbol_string(at)\n\"N\"\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.element_vdw_radius","page":"Atom and element properties","title":"PDBTools.element_vdw_radius","text":"element_vdw_radius(atom::Atom)\n\nReturns the vdW radius of the element of the atom, in Å, or NaN if the data is not available.\n\nExample\n\njulia> using PDBTools \n\njulia> at = Atom(name=\"NT3\");\n\njulia> element_vdw_radius(at)\n1.55f0\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.formula","page":"Atom and element properties","title":"PDBTools.formula","text":"formula(atoms::AbstractVector{<:Atom})\n\nReturns the molecular formula of the current selection. The output is an indexable \"Formula\" structure, where each element is a tuple with the element name and the number of atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> pdb  = read_pdb(PDBTools.TESTPDB, \"residue 1\"); # testing PDB file\n\njulia> resname(pdb[1])\n\"ALA\"\n\njulia> f = formula(pdb)\nH₇C₃N₁O₁\n\njulia> f[1]\n(\"H\", 7)\n\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.stoichiometry","page":"Atom and element properties","title":"PDBTools.stoichiometry","text":"stoichiometry(atoms::AbstractVector{<:Atom})\n\nReturns the stoichiometry of atom selection in a Formula structure. \n\nExample\n\njulia> using PDBTools\n\njulia> pdb  = read_pdb(PDBTools.TESTPDB, \"water\"); # testing PDB file\n\njulia> stoichiometry(pdb)\nH₂O₁\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.printatom","page":"Atom and element properties","title":"PDBTools.printatom","text":"printatom(atom::Atom)\nprintatom(io::IO, atom::Atom)\n\nPrints an Atom structure in a human-readable format, with a title line. By default the output is printed to stdout, and the io argument can be used to specify a different output stream.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and residue 2\");\n\njulia> printatom(atoms[1])\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n      13    N     CYS     A        2        2   -6.351  -14.461   -5.695  1.00  0.00     1    PROT        13\n\njulia> atoms[1] # default show method\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n      13    N     CYS     A        2        2   -6.351  -14.461   -5.695  1.00  0.00     1    PROT        13\n\n\n\n\n\n","category":"function"},{"location":"elements/#Custom-Atom-fields","page":"Atom and element properties","title":"Custom Atom fields","text":"","category":"section"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"Custom atom fields can be created in Atom objects by defining the custom keyword. By default, custom == nothing. The custom fields can be added on construction, or  with the add_custom_field function, which creates a new instance of an Atom  with the added value in the custom field:","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"For example:","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"julia> using PDBTools\n\njulia> atom = Atom(custom=\"TEST\");\n\njulia> atom.custom\n\"TEST\"\n\njulia> atom = Atom(;name = \"CA\", resname=\"ALA\"); # no custom field\n\njulia> atom.resname\n\"ALA\"\n\njulia> new_atom = add_custom_field(atom, Dict(:charge => 2.0));\n\njulia> new_atom.resname\n\"ALA\"\n\njulia> new_atom.custom[:charge]\n2.0\n","category":"page"},{"location":"elements/#PDBTools.add_custom_field","page":"Atom and element properties","title":"PDBTools.add_custom_field","text":"add_custom_field(atom::Atom, value)\n\nAdds a custom field to an Atom structure, returning a new Atom structure with the custom field added. The returning Atom structure is parameterized with the type of value.\n\n\n\n\n\n","category":"function"},{"location":"elements/#Elements-for-custom-atom-types","page":"Atom and element properties","title":"Elements for custom atom types","text":"","category":"section"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"The types of atoms that PDBTools recognizes is defined in the PDBTools.elements dictionary.  If new atom types are defined, it is possible to add these types to the dictionary, such that other functions work for the new types. The function to be used is add_element!.","category":"page"},{"location":"elements/#PDBTools.add_element!","page":"Atom and element properties","title":"PDBTools.add_element!","text":"add_element!(symbol::String, reference_element::PDBTools.Element; elements=PDBTools.elements)\n\nAdd a new element to the elements dictionary. If the element already exists, overwrite it.\n\nTo remove all custom elements, use remove_custom_elements!().\n\nExample\n\njulia> using PDBTools\n\njulia> remove_custom_elements!(); # if any\n\njulia> atoms = [ Atom(name=\"A1\"), Atom(name=\"A2\") ];\n\njulia> add_element!(\"A1\", PDBTools.elements[\"C\"])\nPDBTools.Element(:C, InlineStrings.String3(\"C\"), \"Carbon\", 6, 12.011f0, true, 1.7f0)\n\njulia> add_element!(\"A2\", PDBTools.elements[\"N\"])\nPDBTools.Element(:N, InlineStrings.String3(\"N\"), \"Nitrogen\", 7, 14.0067f0, true, 1.55f0)\n\njulia> element(atoms[1])\n\"C\"\n\njulia> element(atoms[2])\n\"N\"\n\njulia> mass(atoms)\n26.0177f0\n\njulia> remove_custom_elements!(); \n\nHere we repeteadly call remove_custom_elements!() to guarantee the proper execution of the test codes, without any custom elements predefined.\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.remove_custom_elements!","page":"Atom and element properties","title":"PDBTools.remove_custom_elements!","text":"remove_custom_elements!()\n\nRemove all custom elements from the elements dictionary.\n\nExample\n\njulia> using PDBTools\n\njulia> remove_custom_elements!();\n\njulia> add_element!(\"GN\", PDBTools.elements[\"N\"])\nPDBTools.Element(:N, InlineStrings.String3(\"N\"), \"Nitrogen\", 7, 14.0067f0, true, 1.55f0)\n\njulia> element(Atom(name=\"GN\"))\n\"N\"\n\njulia> remove_custom_elements!();\n\njulia> element(Atom(name=\"GN\")) # returns `nothing`\n\n\nHere we repeteadly call remove_custom_elements!() to guarantee the proper execution of the test codes, without any custom elements predefined.\n\n\n\n\n\n","category":"function"},{"location":"elements/#Additional-property-retrieving-and-set-functions","page":"Atom and element properties","title":"Additional property-retrieving and set functions","text":"","category":"section"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"The following functions are supported as part of the API, as a intending to interface with AtomsBase. Nevertheless, currently these functions do not overload the exported ones from AtomsBase, because that package is in a unstable state.","category":"page"},{"location":"elements/","page":"Atom and element properties","title":"Atom and element properties","text":"Function Example Output\natomic_number(::Atom) atomic_number(Atom(name=\"NE2\")) 7\natomic_symbol(::Atom) atomic_symbol(Atom(name=\"NE2\")) :N\natomic_mass(::Atom) atomic_mass(Atom(name=\"NE2\")) 14.0067\nposition(::Atom) position(Atom(name=\"NE2\")) SVector{3,Float64}(0,0,0)\nset_position!(::Atom, x::Union{Tuple,AbstractVector}) set_position!(at, (1,2,3)) Atom","category":"page"},{"location":"elements/#PDBTools.atomic_number","page":"Atom and element properties","title":"PDBTools.atomic_number","text":"atomic_number(atom::Atom)\n\nReturns the atomic number of an atom from its Atom structure.\n\nExample\n\njulia> using PDBTools\n\njulia> at = Atom(name=\"NT3\");\n\njulia> atomic_number(at)\n7\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.atomic_symbol","page":"Atom and element properties","title":"PDBTools.atomic_symbol","text":"atomic_symbol(atom::Atom)\n\nReturns the atomic symbol of an atom given the Atom structure.\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.atomic_mass","page":"Atom and element properties","title":"PDBTools.atomic_mass","text":"atomic_mass(atom::Atom)\n\nReturns the atomic mass of an atom given the Atom structure.\n\n\n\n\n\n","category":"function"},{"location":"elements/#Base.position","page":"Atom and element properties","title":"Base.position","text":"position(atom::Atom)\n\nReturns the position of an atom given the Atom structure.\n\n\n\n\n\n","category":"function"},{"location":"elements/#PDBTools.set_position!","page":"Atom and element properties","title":"PDBTools.set_position!","text":"set_position!(atom::Atom, x::Union{Tuple,AbstractVector})\n\nSets the position (x,y,z coordinates) of the atom, given a vector or tuple of coordinates.\n\n\n\n\n\n","category":"function"},{"location":"iterators/#Iterators","page":"Iterators","title":"Iterators","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"PDBTools.jl provides lazy iterators over Residues, Chains, Segments, and Models of a structure file. The iterators behave similarly, and can be used bo computed properties of independent structural elements. The documentation bellow exemplifies in more detail the features associated to Residue and Chain interators, but the properties and valid for Segment and Model iterators similarly.","category":"page"},{"location":"iterators/#Iterate-over-residues-(or-molecules)","page":"Iterators","title":"Iterate over residues (or molecules)","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The eachresidue iterator enables iteration over the residues of a structure. In PDB files, distinct molecules are often treated as separate residues, so this iterator can be used to iterate over the molecules within a structure. For example:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> protein = read_pdb(PDBTools.SMALLPDB);\n\njulia> count(atom -> resname(atom) == \"ALA\", protein)\n12\n\njulia> count(res -> resname(res) == \"ALA\", eachresidue(protein))\n1","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Here, the first count counts the number of atoms with the residue name \"ALA\", while the second uses eachresidue to count the number of residues named \"ALA\". This highlights the distinction between residue-level and atom-level operations.","category":"page"},{"location":"iterators/#Collecting-Residues-into-a-Vector","page":"Iterators","title":"Collecting Residues into a Vector","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Residues produced by eachresidue can be collected into a vector for further processing:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> protein = read_pdb(PDBTools.SMALLPDB);\n\njulia> residues = collect(eachresidue(protein))\n3-element Vector{Residue}[\n    ALA1A\n    CYS2A\n    ASP3A\n]\n\njulia> residues[1]\n Residue of name ALA with 12 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2 1HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n      11    C     ALA     A        1        1   -7.227  -14.047   -6.599  1.00  0.00     1    PROT        11\n      12    O     ALA     A        1        1   -7.083  -13.048   -7.303  1.00  0.00     1    PROT        12","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"note: Note\nIterators or collected vectors do not create copies of the original atom data. This means that any changes made to the residue vector will directly modify the corresponding data in the original atom vector.","category":"page"},{"location":"iterators/#Iterating-Over-Atoms-Within-Residues","page":"Iterators","title":"Iterating Over Atoms Within Residues","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"You can iterate over the atoms of one or more residues using nested loops. Here, we compute the total number of atoms of ALA residues: ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> protein = read_pdb(PDBTools.SMALLPDB);\n\njulia> n_ala_cys = 0\n       for residue in eachresidue(protein)\n            if name(residue) in (\"ALA\", \"CYS\")\n                for atom in residue\n                   n_ala_cys += 1\n                end\n            end\n       end\n       n_ala_cys\n23","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"This method produces the same result as the more concise approach:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> protein = read_pdb(PDBTools.SMALLPDB);\n\njulia> sum(length(r) for r in eachresidue(protein) if name(r) in (\"ALA\", \"CYS\"))\n23","category":"page"},{"location":"iterators/#Reference-documentation","page":"Iterators","title":"Reference documentation","text":"","category":"section"},{"location":"iterators/#PDBTools.Residue","page":"Iterators","title":"PDBTools.Residue","text":"Residue\n\nResidue data structure. \n\nThe Residue structure carries the properties of the residue or molecule of the atoms it contains, but it does not copy the original vector of atoms, only the residue meta data for each residue. Thus, changes in the residue atoms will be reflected in the original vector of atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> pdb = wget(\"1LBD\");\n\njulia> residues = collect(eachresidue(pdb))\n238-element Vector{Residue}[\n    SER225A\n    ALA226A\n    ⋮\n    MET461A\n    THR462A\n]\n\njulia> resnum.(residues[1:3])\n3-element Vector{Int32}:\n 225\n 226\n 227\n\njulia> residues[5].chain\n\"A\"\n\njulia> residues[8].range\n52:58\n\njulia> mass(residues[1])\n82.0385f0\n\n\n\n\n\n\n","category":"type"},{"location":"iterators/#PDBTools.eachresidue","page":"Iterators","title":"PDBTools.eachresidue","text":"eachresidue(atoms::AbstractVector{<:Atom})\n\nIterator for the residues (or molecules) of a selection. \n\nExample\n\njulia> using PDBTools\n\njulia> atoms = wget(\"1LBD\");\n\njulia> eachresidue(atoms)\n Residue iterator with length = 238\n\njulia> collect(eachresidue(atoms))\n238-element Vector{Residue}[\n    SER225A\n    ALA226A\n    ⋮\n    MET461A\n    THR462A\n]\n\n\n\n\n\n","category":"function"},{"location":"iterators/#PDBTools.resname","page":"Iterators","title":"PDBTools.resname","text":"resname(residue::Union{AbstractString,Char})\n\nReturns the residue name, given the one-letter code or residue name. Differently from threeletter, this function will return the force-field name if available in the list of protein residues.\n\nExamples\n\njulia> resname(\"ALA\")\n\"ALA\"\n\njulia> resname(\"GLUP\")\n\"GLUP\"\n\n\n\n\n\n","category":"function"},{"location":"iterators/#PDBTools.residuename","page":"Iterators","title":"PDBTools.residuename","text":"residuename(residue::Union{AbstractString,Char})\n\nFunction to return the long residue name from other residue codes. The function is case-insensitive.\n\nExamples\n\njulia> residuename(\"A\")\n\"Alanine\"\n\njulia> residuename(\"Glu\")\n\"Glutamic Acid\"\n\n\n\n\n\n\n","category":"function"},{"location":"iterators/#Iterate-over-chains","page":"Iterators","title":"Iterate over chains","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The eachchain iterator in PDBTools enables users to iterate over the chains in a PDB structure. A PDB file may contain multiple protein chains. This iterator simplifies operations involving individual chains.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.CHAINSPDB);\n\njulia> chain.(eachchain(ats)) # Retrieve the names of all chains in the structure\n4-element Vector{InlineStrings.String3}:\n \"A\"\n \"B\"\n \"A\"\n \"D\"\n\njulia> model.(eachchain(ats)) # Retrieve the model numbers associated with each chain\n4-element Vector{Int32}:\n 1\n 1\n 1\n 2\n\njulia> chain_A1 = first(eachchain(ats)); # Access the first chain in the iterator\n\njulia> resname.(eachresidue(chain_A1)) # Retrieve residue names for chain A in model 1\n3-element Vector{InlineStrings.String7}:\n \"ASP\"\n \"GLN\"\n \"LEU\"\n","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"In the example above, the chain. command retrieves the names of all chains in the structure, while  model. command lists the model numbers for each chain. This PDB structure contains two models for chain A, where the third residue changes from leucine (LEU) in model 1 to valine (VAL) in model 2.","category":"page"},{"location":"iterators/#Accessing-Chains-by-Index","page":"Iterators","title":"Accessing Chains by Index","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"As seen in the previous example, The first and last commands allow quick access to the first an last elements in the iterator. For more specific indexing, you can collect all chains into an array and then use numerical indices to access them.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.CHAINSPDB);\n\njulia> chains = collect(eachchain(ats))\n4-element Vector{Chain}[\n    Chain(A-48 atoms)\n    Chain(B-48 atoms)\n    Chain(A-48 atoms)\n    Chain(D-45 atoms)\n]\n\njulia> chain_B = chains[2]\n Chain B with 48 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n      49    N     ASP     B        4        4  135.661  123.866  -22.311  1.00  0.00     1    ASYN        49\n      50   CA     ASP     B        4        4  136.539  123.410  -21.227  1.00  0.00     1    ASYN        50\n⋮\n      95 HD23     LEU     B        6        6  138.780  120.216  -17.864  1.00  0.00     1    ASYN        95\n      96    O     LEU     B        6        6  141.411  117.975  -21.923  1.00  0.00     1    ASYN        96\n","category":"page"},{"location":"iterators/#Modifying-Atom-Properties-in-a-Chain","page":"Iterators","title":"Modifying Atom Properties in a Chain","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Any changes made to the atoms of a chain variable directly overwrite the properties of the original atoms in the structure. For example, modifying the occupancy and beta-factor columns of atoms in model 2 of chain A will update the corresponding properties in the original structure.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"In the example below, the occup and beta properties of all atoms in model 2 of chain A are set to 0.00. The changes are reflected in the original ats vector, demonstrating that the modifications propagate to the parent data structure.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.CHAINSPDB);\n\njulia> first(eachchain(ats))\n Chain A with 48 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ASP     A        1        1  133.978  119.386  -23.646  1.00  0.00     1    ASYN         1\n       2   CA     ASP     A        1        1  134.755  118.916  -22.497  1.00  0.00     1    ASYN         2\n⋮\n      47 HD23     LEU     A        3        3  130.568  111.868  -26.242  1.00  0.00     1    ASYN        47\n      48    O     LEU     A        3        3  132.066  112.711  -21.739  1.00  0.00     1    ASYN        48\n\n \njulia> for chain in eachchain(ats)\n           if name(chain) == \"A\" && model(chain) == 2\n               for atom in chain\n                   atom.occup = 0.00\n                   atom.beta = 0.00\n               end\n           end\n       end\n\njulia> first(eachchain(ats))\n Chain A with 48 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ASP     A        1        1  133.978  119.386  -23.646  1.00  0.00     1    ASYN         1\n       2   CA     ASP     A        1        1  134.755  118.916  -22.497  1.00  0.00     1    ASYN         2\n⋮\n      47 HD23     LEU     A        3        3  130.568  111.868  -26.242  1.00  0.00     1    ASYN        47\n      48    O     LEU     A        3        3  132.066  112.711  -21.739  1.00  0.00     1    ASYN        48\n","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"This behavior ensures efficient data manipulation but requires careful handling to avoid unintended changes. ","category":"page"},{"location":"iterators/#Reference-documentation-2","page":"Iterators","title":"Reference documentation","text":"","category":"section"},{"location":"iterators/#PDBTools.Chain","page":"Iterators","title":"PDBTools.Chain","text":"Chain\n\nCreates a Chain data structure. Chains must be consecutive in the atoms vector, and are identified by having the same chain, segment, and model fields.\n\nThe Chain structure carries the properties of the atoms it contains, but it does not copy the original vector of atoms. This means that any changes made in the Chain structure atoms, will overwrite the original vector of atoms. \n\nExamples\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.CHAINSPDB);\n\njulia> chains = collect(eachchain(ats))\n4-element Vector{Chain}[\n    Chain(A-48 atoms)\n    Chain(B-48 atoms)\n    Chain(A-48 atoms)\n    Chain(D-45 atoms)\n]\n\njulia> chains[1]\n Chain A with 48 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ASP     A        1        1  133.978  119.386  -23.646  1.00  0.00     1    ASYN         1\n       2   CA     ASP     A        1        1  134.755  118.916  -22.497  1.00  0.00     1    ASYN         2\n⋮\n      47 HD23     LEU     A        3        3  130.568  111.868  -26.242  1.00  0.00     1    ASYN        47\n      48    O     LEU     A        3        3  132.066  112.711  -21.739  1.00  0.00     1    ASYN        48\n\njulia> mass(chains[1])\n353.3787f0 \n\njulia> model(chains[4])\n2\n\njulia> segname(chains[2])\n\"ASYN\"\n\n\n\n\n\n","category":"type"},{"location":"iterators/#PDBTools.eachchain","page":"Iterators","title":"PDBTools.eachchain","text":"eachchain(atoms::AbstractVector{<:Atom})\n\nIterator for the chains of a selection. \n\nExample\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.CHAINSPDB);\n\njulia> eachchain(ats)\n Chain iterator with length = 4\n\njulia> chains = collect(eachchain(ats))\n4-element Vector{Chain}[\n    Chain(A-48 atoms)\n    Chain(B-48 atoms)\n    Chain(A-48 atoms)\n    Chain(D-45 atoms)\n]\n\n\n\n\n\n","category":"function"},{"location":"iterators/#Iterate-over-segments","page":"Iterators","title":"Iterate over segments","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The eachsegment iterator enables iteration over the segments of a structure. For example:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> eachsegment(ats)\n Segment iterator with length = 2\n\njulia> name.(eachsegment(ats))\n2-element Vector{InlineStrings.String7}:\n \"A\"\n \"B\"","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The result of the iterator can also be collected, with:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> s = collect(eachsegment(ats))\n2-element Vector{Segment}[ \n    A-(1905 atoms))\n    B-(92 atoms))\n]\n\njulia> s[1]\n Segment of name A with 1905 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     LYS     A      211        1   52.884   24.022   35.587  1.00 53.10     1       A         1\n       2   CA     LYS     A      211        1   52.916   24.598   36.993  1.00 53.10     1       A         2\n⋮\n    1904  OD2     ASP     A      461      243   17.538   51.009   45.748  1.00 97.43     1       A      1904\n    1905  OXT     ASP     A      461      243   14.506   47.082   47.528  1.00 97.43     1       A      1905","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"These segment structure does not copy the data from the original atom vector. Therefore, changes performed on these vectors will be reflected on the original data.  ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Iterators can be used to obtain or modify properties of the segments. Here we illustrate computing the mass of each segment and renaming segment of all atoms with the segment indices:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> s = collect(eachsegment(ats))\n2-element Vector{Segment}[ \n    A-(1905 atoms))\n    B-(92 atoms))\n]\n\njulia> mass.(s)\n2-element Vector{Float32}:\n 25222.553\n  1210.7296\n\njulia> for (iseg, seg) in enumerate(eachsegment(ats))\n           for at in seg\n               at.segname = \"$(at.segname)$iseg\"\n           end\n       end\n\njulia> collect(eachsegment(ats))\n2-element Vector{Segment}[ \n    A1-(1905 atoms))\n    B2-(92 atoms))\n]","category":"page"},{"location":"iterators/#Reference-documentation-3","page":"Iterators","title":"Reference documentation","text":"","category":"section"},{"location":"iterators/#PDBTools.Segment","page":"Iterators","title":"PDBTools.Segment","text":"Segment\n\nSegment data structure. Segments must be consecutive in the atoms vector, and are identified by having the same segname and model fields.\n\nThe Segment structure carries the properties of the segment  it contains, but it does not copy the original vector of atoms, only the segment meta data and the reference to the original vector. Thus, changes in the segment atoms will be reflected in the original vector of atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> segments = collect(eachsegment(ats))\n2-element Vector{Segment}[\n    A-(1905 atoms))\n    B-(92 atoms))\n]\n\njulia> segname.(segments[1:2])\n2-element Vector{InlineStrings.String7}:\n \"A\"\n \"B\"\n\njulia> length(segments[2])\n92\n\n\n\n\n\n\n","category":"type"},{"location":"iterators/#PDBTools.eachsegment","page":"Iterators","title":"PDBTools.eachsegment","text":"eachsegment(atoms::AbstractVector{<:Atom})\n\nIterator for the segments of a selection.\n\nExample\n\njulia> using PDBTools\n\njulia> ats = read_pdb(PDBTools.DIMERPDB);\n\njulia> sit = eachsegment(ats)\n Segment iterator with length = 2\n\njulia> for seg in sit\n           @show length(seg)\n       end\nlength(seg) = 1905\nlength(seg) = 92\n\njulia> collect(sit)\n2-element Vector{Segment}[ \n    A-(1905 atoms))\n    B-(92 atoms))\n]\n\n\n\n\n\n","category":"function"},{"location":"iterators/#Iterate-over-models","page":"Iterators","title":"Iterate over models","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The eachmodel iterator enables iteration over the segments of a structure. For example:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> ats = wget(\"8S8N\");\n\njulia> eachmodel(ats)\n Model iterator with length = 11\n\njulia> model.(eachmodel(ats))\n11-element Vector{Int32}:\n  1\n  2\n  3\n  ⋮\n 10\n 11","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The result of the iterator can also be collected, with:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> ats = wget(\"8S8N\");\n\njulia> m = collect(eachmodel(ats))\n11-element Vector{Model}[\n    1-(234 atoms))\n    2-(234 atoms))\n    ⋮\n    10-(234 atoms))\n    11-(234 atoms))\n]\n\njulia> m[1]\n Model 1 with 234 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     DLE     A        2        1   -5.811   -0.380   -2.159  1.00  0.00     1                 1\n       2   CA     DLE     A        2        1   -4.785   -0.493   -3.227  1.00  0.00     1                 2\n⋮\n     233  HT2   A1H5T     B      101       13   -5.695    5.959   -3.901  1.00  0.00     1               233\n     234  HT1   A1H5T     B      101       13   -4.693    4.974   -2.743  1.00  0.00     1               234","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The model structure does not copy the data from the original atom vector. Therefore, changes performed on these vectors will be reflected on the original data.  ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Iterators can be used to obtain or modify properties of the segments. Here we illustrate computing the mass of each segment and renaming segment of all atoms with the segment indices:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"julia> using PDBTools\n\njulia> ats = wget(\"8S8N\");\n\njulia> center_of_mass.(eachmodel(ats))\n11-element Vector{StaticArraysCore.SVector{3, Float32}}:\n [0.6337627, -0.14130484, -0.2179606]\n [0.56077266, -0.15154965, 0.1354806]\n [0.5065595, -0.0977174, 0.030405657]\n ⋮\n [0.38899764, -0.21103837, 0.2180245]\n [0.69953984, -0.15372278, 0.21793146]\n","category":"page"},{"location":"iterators/#Reference-documentation-4","page":"Iterators","title":"Reference documentation","text":"","category":"section"},{"location":"iterators/#PDBTools.Model","page":"Iterators","title":"PDBTools.Model","text":"Model\n\nModel data structure. It carries the data of a model in a PDB file. Models must be consecutive in the atoms vector, and are identified by having the same model field.\n\nThe Model structure carries the properties of the model it contains, but it does not copy the original vector of atoms, only the model meta data and the reference to the original vector. Thus, changes in the model atoms will be reflected in the original vector of atoms.\n\nExample\n\nIn the example below, 8S8N is PDB entry with 11 models.\n\njulia> using PDBTools\n\njulia> ats = wget(\"8S8N\");\n\njulia> models = collect(eachmodel(ats))\n11-element Vector{Model}[\n    1-(234 atoms))\n    2-(234 atoms))\n    ⋮\n    10-(234 atoms))\n    11-(234 atoms))\n]\n\njulia> models[1]\n Model 1 with 234 atoms.\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     DLE     A        2        1   -5.811   -0.380   -2.159  1.00  0.00     1                 1\n       2   CA     DLE     A        2        1   -4.785   -0.493   -3.227  1.00  0.00     1                 2\n⋮\n     233  HT2   A1H5T     B      101       13   -5.695    5.959   -3.901  1.00  0.00     1               233\n     234  HT1   A1H5T     B      101       13   -4.693    4.974   -2.743  1.00  0.00     1               234\n\n\n\n\n\n\n","category":"type"},{"location":"iterators/#PDBTools.eachmodel","page":"Iterators","title":"PDBTools.eachmodel","text":"eachmodel(atoms::AbstractVector{<:Atom})\n\nIterator for the models of a selection.\n\nExample\n\nHere we show how to iterate over the models of a PDB file, annotate  the index of the first atom of each model, and collect all models.\n\njulia> using PDBTools\n\njulia> ats = wget(\"8S8N\");\n\njulia> models = eachmodel(ats)\n Model iterator with length = 11\n\njulia> first_atom = Atom[]\n       for model in models\n           push!(first_atom, model[1])\n       end\n       @show index.(first_atom);\nindex.(first_atom) = Int32[1, 235, 469, 703, 937, 1171, 1405, 1639, 1873, 2107, 2341]\n\njulia> collect(models)\n11-element Vector{Model}[\n    1-(234 atoms))\n    2-(234 atoms))\n    ⋮\n    10-(234 atoms))\n    11-(234 atoms))\n]\n\n\n\n\n\n","category":"function"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"These tools may call external programs to perform each task. Please verify the installation of  the necessary tool for each case. ","category":"page"},{"location":"tools/#Solvent-Accessible-Surface-Area-(SASA)","page":"Tools","title":"Solvent Accessible Surface Area (SASA)","text":"","category":"section"},{"location":"tools/#PDBTools.sasa_particles","page":"Tools","title":"PDBTools.sasa_particles","text":"sasa_particles(atoms; probe_radius, n_dots)\n\nCalculates the Solvent Accessible Surface Area (SASA) for a vector of Atoms. \n\nMain argument\n\natoms::Vector{PDBTools.Atom}: A vector of atoms in the molecule.\n\nReturns\n\nPDBTools.SASA structure, containing the vector of atoms, the SASA of each atom (in Å²) and, optionally, the solvent accessible dots that define the surface. \n\nThe sasa function computes the total SASA or the SASA of a subset of the atoms in the structure.\n\nOptional arguments\n\nprobe_radius::Real=1.4f0: The radius of the solvent probe in Angstroms.\nn_dots::Int=512: The number of grid points along one axis for dot generation.  Higher values lead to more accurate but slower calculations.\nunitcell=nothing: if periodic boundary conditions are used, provide a 3x3 matrix with the unitcell, or alternatively a vector of length 3 with the sides, for orthorhombic cells.\nparallel::Bool=true: Control if the computation runs in parallel (requires  running Julia with multiple threads).\n\nExample\n\njulia> using PDBTools\n\njulia> prot = select(read_pdb(PDBTools.TESTPDB), \"protein\");\n\njulia> at_sasa = sasa_particles(prot);\n\njulia> sasa(at_sasa) # total sasa of prot\n5389.0146f0\n\njulia> sasa(at_sasa, \"backbone\") # backbone sasa in prot\n988.7648f0\n\njulia> sasa(at_sasa, \"not backbone\") # other atoms\n4400.246f0\n\njulia> sasa(at_sasa, \"resname ARG GLU\") # some residue types\n543.29846f0\n\nAdditional control:\n\nTwo arguments can control the atom radii used for computing the SASA. These arguments are functions:\n\natom_type: Function that given each atom of the array of atoms, returns the atom \"type\".\natom_radius_from_type: Given the atom \"type\", returns the vdW radius of the atom. \noutput_dots::Bool=false: If true, the resulting SASA structure will contain the solvent accessible   dots per particle in the dots field.\n\nBy default, atom_type = PDBTools.element, a function that just returns the element symbol of the atom, and atom_radius_from_type obtains the vdW radius from the PDBTools.elements list given the element symbol. Here, the atomc radii of https://en.wikipedia.org/wiki/Atomicradiioftheelements(datapage) are used.  Atoms with missing radius have a NaN value, and the computation will not return meaningful values. \n\n\n\n\n\n","category":"function"},{"location":"tools/#PDBTools.sasa","page":"Tools","title":"PDBTools.sasa","text":"sasa(s::SASA)\nsasa(s::SASA{<:AbstractVector{<:PDBTools.Atom}})\nsasa(atoms::SASA{<:AbstractVector{PDBTools.Atom}}, selection::Union{Function,String})\n\nGiven the output of sasa_particles, sums up contributions of atoms to compute the SASA of the full structure, an atom, or a subset of atoms. The function can be called with only a  SASA object (in which case the full SASA is returned), or with the object and a selection, given by a function or selection string. \n\nExample\n\njulia> using PDBTools\n\njulia> prot = select(read_pdb(PDBTools.TESTPDB), \"protein\");\n\njulia> at_sasa = sasa_particles(prot);\n\njulia> sasa(at_sasa) # total sasa of prot\n5389.0146f0\n\njulia> sasa(at_sasa, \"backbone\") # selection string\n988.7648f0\n\njulia> sasa(at_sasa, at -> name(at) == \"CA\") # selection function\n44.078426f0\n\njulia> sasa(at_sasa[1]) # single atom SASA\n5.467941f0\n\n\n\n\n\n","category":"function"},{"location":"tools/","page":"Tools","title":"Tools","text":"A typical run of these functions consists in providing the structure of a protein to the first function, sasa_particles, to obtain a SASA object, which contains the accessible area per atom:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using PDBTools\nprot = read_pdb(PDBTools.TESTPDB, \"protein\")\natom_sasa = sasa_particles(prot)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The atom_sasa object created above can be used to extract the total accessible area or the accessible area of any sub-surface. The sasa function provides an interface for those extractions:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"sasa(atom_sasa) # total","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"sasa(atom_sasa, \"polar\") ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"sasa(atom_sasa, \"backbone\")","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"sasa(atom_sasa, \"resname THR and residue < 50\") ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"In some situations, it might be useful to visualize the surface. The dots that form the surface can be obtained by running sasa_particles with the output_dots option set to true. Here, we use fewer dots for better visualization:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"atom_sasa = sasa_particles(prot; n_dots=100, output_dots=true) ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Where the atom_sasa.dots field contais the dots that are accessible to the surface for each atom. These can be plotted, for example, with:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using Plots\ndots = reduce(vcat, atom_sasa.dots)\nscatter(Tuple.(coor.(prot)); color=:orange, msw=0, label=\"\") # atom coordinates\nscatter!(Tuple.(dots); # surface dots\n    color=:blue, ms=1, msw=0, ma=0.5, # marker properties\n    label=\"\",\n)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"note: Note\nThe sasa_particles function supports periodic boundary conditions if a unit cell is provided.  See the read_unitcell and cryst1_to_matrix functions for further information.","category":"page"},{"location":"tools/#Read-and-convert-unit-cells","page":"Tools","title":"Read and convert unit cells","text":"","category":"section"},{"location":"tools/#PDBTools.read_unitcell","page":"Tools","title":"PDBTools.read_unitcell","text":"read_unitcell(file::AbstractString)\n\nReads the lattice parameters of unitcell from a PDB (CRYST1 field) or mmCIF file, and converts it to a unitcell matrix with the lattice_to_matrix function. The unitcell matrix contains the lattice vectors as the columns of the matrix. \n\nExample\n\njulia> using PDBTools\n\njulia> m = read_unitcell(PDBTools.TESTPBC)\n3×3 StaticArraysCore.SMatrix{3, 3, Float32, 9} with indices SOneTo(3)×SOneTo(3):\n 85.0  -3.71547f-6  -3.71547f-6\n  0.0  85.0         -3.71547f-6\n  0.0   0.0         85.\n\njulia> matrix_to_lattice(m)\n(a = 85.0f0, b = 85.0f0, c = 85.0f0, α = 90.0f0, β = 90.0f0, γ = 90.0f0)\n\n\n\n\n\n","category":"function"},{"location":"tools/#PDBTools.lattice_to_matrix","page":"Tools","title":"PDBTools.lattice_to_matrix","text":"lattice_to_matrix(a, b, c, α, β, γ)\n\nConverts unit cell lattice parameters and convert them to a 3x3 unit cell matrix (orthogonalization matrix), where the lattice vectors are the columns of the matrix.\n\nThe resulting matrix has the lattice vectors as its columns, with vector 'a' aligned along the x-axis and vector 'b' in the xy-plane. This matrix can be used to transform fractional coordinates to Cartesian coordinates.\n\nArguments\n\na::Real: Length of side a in Ångströms.\nb::Real: Length of side b in Ångströms.\nc::Real: Length of side c in Ångströms.\nα::Real: Angle alpha in degrees.\nβ::Real: Angle beta in degrees.\nγ::Real: Angle gamma in degrees.\n\nReturns\n\nA 3x3 static matrix representing the unit cell vectors.\n\n\n\n\n\n","category":"function"},{"location":"tools/#PDBTools.matrix_to_lattice","page":"Tools","title":"PDBTools.matrix_to_lattice","text":"matrix_to_lattice(M::AbstractMatrix)\n\nConverts a 3x3 unit cell matrix where the lattice vectors are the columns, back into the six  lattice parameters (sides a, b, c and angles α, β, γ).\n\nArguments\n\nM::AbstractMatrix: A 3x3 matrix where columns are the lattice vectors.\n\nReturns\n\nNamedTuple: A named tuple containing the six parameters: (a, b, c, α, β, γ). Lengths are in the matrix's original units (typically Ångströms), and angles are in degrees.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Check-the-stereochemistry-of-protein-residues","page":"Tools","title":"Check the stereochemistry of protein residues","text":"","category":"section"},{"location":"tools/#PDBTools.zeta","page":"Tools","title":"PDBTools.zeta","text":"zeta(r::Residue)\n\nComputes the Cα chirality (zeta \"virtual\" torsion angle - Cα-N-C-Cβ).\n\nReturns the torsion angle or NaN if the residue is not recognized a protein residue or if its a Gly residue. Expected values are 33.9 ± 3.5 degrees (for one standard deviation). Also see the zeta_check function.\n\nExample\n\njulia> using PDBTools\n\njulia> protein = select(read_pdb(PDBTools.TESTPDB), \"protein\");\n\njulia> residues = collect(eachresidue(protein));\n\njulia> zeta(residues[1])\n33.67202f0\n\n\n\n\n\n","category":"function"},{"location":"tools/#PDBTools.zeta_check","page":"Tools","title":"PDBTools.zeta_check","text":"zeta_check(r::Residue; nsigma=2)\n\nChecks if the Cα chirality falls into expected ranges. See the zeta function for further information. The expected mean is 33.9 degrees with a standard deviation of 3.5 degrees. By default, nsigma=2, implying that the function returns true if the torsion falls  within two standard deviations from the mean.\n\nSee: https://www.ebi.ac.uk/thornton-srv/software/PROCHECK/manual/manappa.html\n\nExample\n\njulia> using PDBTools\n\njulia> protein = select(read_pdb(PDBTools.TESTPDB), \"protein\");\n\njulia> residues = collect(eachresidue(protein));\n\njulia> zeta_check(residues[1])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"tools/#Add-hydrogens-with-OpenBabel","page":"Tools","title":"Add hydrogens with OpenBabel","text":"","category":"section"},{"location":"tools/#PDBTools.add_hydrogens!","page":"Tools","title":"PDBTools.add_hydrogens!","text":"add_hydrogens!(atoms::AbstractVector{<:Atom}; pH=7.0, obabel=\"obabel\", debug=false)\n\nAdd hydrogens to a PDB file using Open Babel. \n\nArguments\n\natoms::AbstractVector{<:Atom}: structure (usually PDB file of a protein) to add hydrogens to.\npH: the pH of the solution. Default is 7.0.\nobabel: path to the obabel executable. Default is \"obabel\".\ndebug: if true, print the output message from obabel. Default is false.\n\nnote: Note\nThis function requires the installation of OpenBabel. Please cite the corresponding reference if using it.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB, \"protein and not element H\");\n\njulia> add_hydrogens!(atoms)\n   Vector{Atom{Nothing}} with 1459 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  1.00  0.00     1       -         1\n       2   CA     ALA     A        1        1   -8.483  -14.912   -6.726  1.00  0.00     1       -         2\n       3   CB     ALA     A        1        1   -9.383  -14.465   -7.880  1.00  0.00     1       -         3\n                                                       ⋮ \n    1457    H     THR     A      104      208    5.886  -10.722   -7.797  1.00  0.00     1       -      1457\n    1458    H     THR     A      104      208    5.871  -10.612   -9.541  1.00  0.00     1       -      1458\n    1459    H     THR     A      104      208    6.423  -12.076   -8.762  1.00  0.00     1       -      1459\n\n\n\n\n\n","category":"function"},{"location":"tools/#Custom-protein-residue-types","page":"Tools","title":"Custom protein residue types","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"It is possible to add to the list of protein residues, custom residue types.  This can be done by simply adding to the PDBTools.protein_residues dictionary of residues a new PDBTools.ProteinResidue entry. For example, here we create a new resiude type NEW with the same properties of an ALA residue. To  remove all custom protein residues, use remove_custom_protein_residues!().","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"julia> using PDBTools\n\njulia> remove_custom_protein_residues!();\n\njulia> add_protein_residue!(\"NEW\", PDBTools.protein_residues[\"ALA\"])\nPDBTools.ProteinResidue(\"NEW\", \"ALA\", \"A\", \"Aliphatic\", false, true, 71.037114, 71.0779, 0, true)\n\njulia> atom = Atom(resname=\"NEW\");\n\njulia> isprotein(atom)\ntrue\n\njulia> remove_custom_protein_residues!();","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Here we repeteadly call remove_custom_residues!() to guarantee the proper execution of the test codes, without any custom residues in the list of protein residues.","category":"page"},{"location":"tools/#PDBTools.add_protein_residue!","page":"Tools","title":"PDBTools.add_protein_residue!","text":"add_protein_residue!(resname::String, reference_residue::PDBTools.ProteinResidue)\n\nFunction to add a custom protein residue to the list of protein residues. The function will return the ProteinResidue object that was added. To remove all custom protein residues use remove_custom_protein_residues!().\n\nExample\n\njulia> using PDBTools\n\njulia> remove_custom_protein_residues!();\n\njulia> add_protein_residue!(\"sA\", PDBTools.protein_residues[\"ALA\"])\nPDBTools.ProteinResidue(\"sA\", \"ALA\", \"A\", \"Aliphatic\", false, true, 71.037114, 71.0779, 0, true)\n\njulia> isprotein(Atom(resname=\"sA\"))\ntrue\n\njulia> remove_custom_protein_residues!(); # clean up\n\nHere we repeteadly call remove_custom_residues!() to guarantee the proper execution of the test codes, without any custom residues in the list of protein residues.\n\n\n\n\n\n","category":"function"},{"location":"tools/#PDBTools.remove_custom_protein_residues!","page":"Tools","title":"PDBTools.remove_custom_protein_residues!","text":"remove_custom_protein_residues!()\n\nFunction to remove all custom protein residues from the list of protein residues.\n\nExample\n\njulia> using PDBTools\n\njulia> remove_custom_protein_residues!(); # clean up\n\njulia> add_protein_residue!(\"sA\", PDBTools.protein_residues[\"ALA\"])\nPDBTools.ProteinResidue(\"sA\", \"ALA\", \"A\", \"Aliphatic\", false, true, 71.037114, 71.0779, 0, true)\n\njulia> isprotein(Atom(resname=\"sA\"))\ntrue\n\njulia> remove_custom_protein_residues!();\n\njulia> isprotein(Atom(resname=\"sA\"))\nfalse\n\nHere we repeteadly call remove_custom_residues!() to guarantee the proper execution of the test codes, without any custom residues in the list of protein residues.\n\n\n\n\n\n","category":"function"},{"location":"tools/#The-SIRAH-force-field-residues-and-element-types","page":"Tools","title":"The SIRAH force-field residues and element types","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Conveniencie functions can be created to add sets of new types of residues and atom types to the list of residues and elements. This is illustrated in the  custom_types.jl file of the source code, in this case for the residues and atom types of the SIRAH force field for Coarse-Grained protein simulations.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"With those definitions, adding all SIRAH protein residue types and element names can be done with:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"julia> using PDBTools \n\njulia> remove_custom_protein_residues!(); remove_custom_elements!();\n\njulia> custom_protein_residues!(SIRAH)\n┌ Warning: \n│ \n│     Residue `sX` will be interpreted as bridged Cysteine.\n│ \n└ @ PDBTools\n\njulia> custom_elements!(SIRAH)\n┌ Warning:\n│\n│     The element masses are not the coarse-grained ones. This must be fixed in the future.\n│\n└ @ PDBTools\n\njulia> sirah_pdb = read_pdb(PDBTools.SIRAHPDB);\n\njulia> resname.(eachresidue(sirah_pdb))\n5-element Vector{InlineStrings.String7}:\n \"sI\"\n \"sR\"\n \"sX\"\n \"sI\"\n \"sG\"\n\njulia> getseq(sirah_pdb)\n5-element Vector{String}:\n \"I\"\n \"R\"\n \"C\"\n \"I\"\n \"G\"\n\njulia> all(isprotein.(sirah_pdb))\ntrue\n\njulia> remove_custom_protein_residues!(); remove_custom_elements!();","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Note that the residue names of the SIRAH force-field are non-standard (sI, sR, etc.), but the sequence is properly retrieved with standard one-letter codes, and all the atoms of the structure are recognized  as being \"protein\" atoms.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Here we repeteadly call remove_custom_residues!() and remove_custom_elements!() to guarantee the proper execution of the test codes.","category":"page"},{"location":"tools/#Move-atoms-and-center-of-mass","page":"Tools","title":"Move atoms and center of mass","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The center_of_mass function can be used to compute the center of mass of set of atoms, and the  moveto! function can be used to move the center of mass of the atoms to the origin (by default)  or to a specified position:","category":"page"},{"location":"tools/#MolSimToolkitShared.center_of_mass","page":"Tools","title":"MolSimToolkitShared.center_of_mass","text":"center_of_mass(atoms::AbstractVector{<:Atom})\n\nCalculate the center of mass of the atoms.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> center_of_mass(atoms)\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n  -5.5844226\n -13.1104145\n  -7.1399713\n\n\n\n\n\n","category":"function"},{"location":"tools/#PDBTools.moveto!","page":"Tools","title":"PDBTools.moveto!","text":"moveto!(atoms::AbstractVector{<:Atom}; center::AbstractVector{<:Real}=SVector(0.0, 0.0, 0.0))\n\nMove the center of mass of the atoms to the specified center position, which defaults to the origin.\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB);\n\njulia> center_of_mass(atoms)\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n  -5.5844226\n -13.1104145\n  -7.1399713\n\njulia> moveto!(atoms; center = [1.0, 2.0, 3.0]);\n\njulia> center_of_mass(atoms)\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n 1.0\n 2.0000014\n 3.0\n\n\n\n\n\n","category":"function"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Selecting-the-active-site-of-a-protein","page":"Examples","title":"Selecting the active site of a protein","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 1BSX pdb file is a structure that contains a dimer of the thyroid hormone receptor-beta bound to the ligand T3. Here we select all residues of chain A, which is one of the monomers, that within 3.5AA of the ligand:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using PDBTools\n\njulia> atoms = wget(\"1BSX\", \"chain A\"; format=\"PDB\");\n\njulia> protein = select(atoms, \"protein\");\n\njulia> ligand = select(atoms, \"resname T3\");\n\njulia> active_site_atoms = Atom[]\n       for residue in eachresidue(protein)\n           if distance(residue, ligand) < 3.5\n               append!(active_site_atoms, atom for atom in residue)\n           end\n       end\n\njulia> length(active_site_atoms)\n56\n\njulia> resname.(eachresidue(active_site_atoms))\n6-element Vector{InlineStrings.String7}:\n \"PHE\"\n \"ARG\"\n \"LEU\"\n \"ASN\"\n \"LEU\"\n \"HIS\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nThe Atom[] creates an empty vector of PDBTools.Atom objects, and we append to this array the list of atoms of each residue. \nWe opt here to download the file in the \"PDB\" format, because the chain identifier in the mmCIF deposited file does not include the ligand in chain A.","category":"page"},{"location":"examples/#Storing-partial-charges","page":"Examples","title":"Storing partial charges","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we exemplify the use of a custom field to store partial charges for all atoms in a protein:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using PDBTools\n\njulia> ats = wget(\"1BSX\", \"protein\");\n\njulia> charges = ones(length(ats));\n\njulia> ats_with_charges = add_custom_field.(ats, charges); # charges in custom field\n\njulia> ats_with_charges[1].custom\n1.0\n","category":"page"},{"location":"readwrite/#Read-and-write-files","page":"Read and Write","title":"Read and write files","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"PDBTools can read and write PDB and mmCIF files. The relevant functions are:","category":"page"},{"location":"readwrite/#PDBTools.read_pdb","page":"Read and Write","title":"PDBTools.read_pdb","text":"read_pdb(pdbfile::String, selection::String)\nread_pdb(pdbfile::String, selection_function::Function = all)\n\nread_pdb(pdbdata::IOBuffer, selection::String)\nread_pdb(pdbdata::IOBuffer, selection_function::Function = all)\n\nReads a PDB file and stores the data in a vector of type Atom. \n\nIf a selection is provided, only the atoms matching the selection will be read.  For example, resname ALA will select all the atoms in the residue ALA.\n\nIf a selection function keyword is provided, only the atoms for which selection_function(atom) is true will be read.\n\nExamples\n\njulia> using PDBTools\n\njulia> protein = read_pdb(PDBTools.TESTPDB)\n   Vector{Atom{Nothing}} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  1.00  0.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  1.00  0.00     1    WAT2     62026\n\njulia> ALA = read_pdb(PDBTools.TESTPDB,\"resname ALA\")\n   Vector{Atom{Nothing}} with 72 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n    1339    C     ALA     A       95       95   14.815   -3.057   -5.633  1.00  0.00     1    PROT      1339\n    1340    O     ALA     A       95       95   14.862   -2.204   -6.518  1.00  0.00     1    PROT      1340\n\njulia> ALA = read_pdb(PDBTools.TESTPDB, atom -> atom.resname == \"ALA\")\n   Vector{Atom{Nothing}} with 72 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n    1339    C     ALA     A       95       95   14.815   -3.057   -5.633  1.00  0.00     1    PROT      1339\n    1340    O     ALA     A       95       95   14.862   -2.204   -6.518  1.00  0.00     1    PROT      1340\n\n\n\n\n\n","category":"function"},{"location":"readwrite/#PDBTools.read_mmcif","page":"Read and Write","title":"PDBTools.read_mmcif","text":"read_mmcif(mmCIF_file::String, selection::String; field_assignment)\nread_mmcif(mmCIF_file::String, selection_function::Function = all, field_assignment)\n\nread_mmcif(mmCIF_data::IOBuffer, selection::String; field_assignment)\nread_mmcif(mmCIF_data::IOBuffer, selection_function::Function = all, field_assignment)\n\nReads a mmCIF file and stores the data in a vector of type Atom. \n\nAll fields except the file name are optional.\n\nIf a selection is provided, only the atoms matching the selection will be read.  For example, resname ALA will select all the atoms in the residue ALA.\n\nIf a selection function is provided, only the atoms for which selection_function(atom) is true will be returned.\n\nThe field_assignment keyword is nothing (default) or a Dict{String,Symbol} and can be used to specify which fields in the mmCIF file should be read into the Atom type. For example field_assignment = Dict(\"type_symbol\" => :name) will read the _atom_site.type_symbol field in the mmCIF  file into the name field of the Atom type.\n\nThe default assignment is follows the standard mmCIF convention:\n\nDict{String,Symbol}(\n    \"id\" => :index_pdb\n    \"Cartn_x\" => :x\n    \"Cartn_y\" => :y\n    \"Cartn_z\" => :z\n    \"occupancy\" => :occup\n    \"B_iso_or_equiv\" => :beta\n    \"pdbx_formal_charge\" => :charge\n    \"pdbx_PDB_model_num\" => :model\n    \"label_atom_id\" => :name\n    \"label_comp_id\" => :resname\n    \"label_asym_id\" => :chain\n    \"auth_seq_id\" => :resnum\n    \"type_symbol\" => :pdb_element\n)\n\nSource: https://mmcif.wwpdb.org/docs/tutorials/content/atomic-description.html\n\nExamples\n\njulia> using PDBTools\n\njulia> ats = read_mmcif(PDBTools.TESTCIF)\n   Vector{Atom{Nothing}} with 76 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     GLY     A        1        1   -4.564   25.503   24.113  1.00 24.33     1                 1\n       2   CA     GLY     A        1        1   -4.990   26.813   24.706  1.00 24.29     1                 2\n⋮\n      75    O     HOH     Q       63       15   -3.585   34.725   20.903  1.00 19.82     1              2980\n      76    O     HOH     Q       64       16   -4.799   40.689   37.419  1.00 20.13     1              2981\n\njulia> ats = read_mmcif(PDBTools.TESTCIF, \"index < 3\")\n   Vector{Atom{Nothing}} with 2 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     GLY     A        1        1   -4.564   25.503   24.113  1.00 24.33     1                 1\n       2   CA     GLY     A        1        1   -4.990   26.813   24.706  1.00 24.29     1                 2\n\njulia> ats = read_mmcif(PDBTools.TESTCIF, at -> name(at) == \"CA\")\n   Vector{Atom{Nothing}} with 11 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       2   CA     GLY     A        1        1   -4.990   26.813   24.706  1.00 24.29     1                 2\n       6   CA     GLN     A        2        2   -4.738   30.402   23.484  1.00 23.74     1                 6\n⋮\n      70   CA      CA     G     1003       10  -24.170   27.201   64.364  1.00 27.40     1              2967\n      71   CA      CA     H     1004       11  -10.624   32.854   69.292  1.00 29.53     1              2968\n\n\n\n\n\n\n","category":"function"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"note: Note\nIn the following examples, the read_pdb function will be illustrated. The usage is similar to that of read_mmcif, to read mmCIF (PDBx) files. ","category":"page"},{"location":"readwrite/#Read-a-PDB/mmCIF-file","page":"Read and Write","title":"Read a PDB/mmCIF file","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"To read a PDB file and return a vector of atoms of type Atom, do:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"atoms = read_pdb(\"file.pdb\")","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"Atom is the structure of data containing the atom index, name, residue, coordinates, etc. For example, after reading a file (as shown bellow), a list of atoms with the following structure will be generated:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> printatom(atoms[1])\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  1.00     1    PROT         1","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"The data in the Atom structure is organized as indicated in the following documentation:","category":"page"},{"location":"readwrite/#PDBTools.Atom","page":"Read and Write","title":"PDBTools.Atom","text":"Atom::DataType\n\nStructure that contains the atom properties. It is mutable, so its fields can be modified.\n\nFields:\n\nmutable struct Atom{CustomType}\n    index::Int32 # The sequential index of the atoms in the file\n    index_pdb::Int32 # The index as written in the PDB file (might be anything)\n    name::String7 # Atom name\n    resname::String7 # Residue name\n    chain::String3 # Chain identifier\n    resnum::Int32 # Number of residue as written in PDB file\n    residue::Int32 # Sequential residue (molecule) number in file\n    x::Float32 # x coordinate\n    y::Float32 # y coordinate\n    z::Float32 # z coordinate\n    beta::Float32 # temperature factor\n    occup::Float32 # occupancy\n    model::Int32 # model number\n    segname::String7 # Segment name (cols 73:76)\n    pdb_element::String3 # Element symbol string (cols 77:78)\n    charge::Float32 # Charge (cols: 79:80)\n    custom::CustomType # Custom fields\n    flag::Int8 # Flag for internal use\nend\n\nExample\n\njulia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.SMALLPDB)\n   Vector{Atom{Nothing}} with 35 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2 1HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n      34    C     ASP     A        3        3   -2.626  -10.480   -7.749  1.00  0.00     1    PROT        34\n      35    O     ASP     A        3        3   -1.940  -10.014   -8.658  1.00  0.00     1    PROT        35\n\njulia> resname(atoms[1])\n\"ALA\"\n\njulia> chain(atoms[1])\n\"A\"\n\njulia> element(atoms[1])\n\"N\"\n\njulia> mass(atoms[1])\n14.0067f0\n\njulia> position(atoms[1])\n3-element StaticArraysCore.SVector{3, Float32} with indices SOneTo(3):\n  -9.229\n -14.861\n  -5.481\n\nThe pdb_element and charge fields, which are frequently left empty in PDB files, are not printed.  The direct access to the fields is considered part of the interface.\n\nCustom fields can be set on Atom construction with the custom keyword argument. The Atom structure will then be parameterized with the type of custom. \n\nExample\n\njulia> using PDBTools\n\njulia> atom = Atom(index = 0; custom=Dict(:c => \"c\", :index => 1));\n\njulia> typeof(atom)\nAtom{Dict{Symbol, Any}}\n\njulia> atom.custom\nDict{Symbol, Any} with 2 entries:\n  :index => 1\n  :c     => \"c\"\n\njulia> atom.custom[:c]\n\"c\"\n\n\n\n\n\n","category":"type"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"tip: Tip\nFor all these reading and writing functions, a final argument can be provided to read or write a subset of the atoms, following the selection syntax described  in the Selection section. For example:protein = read_pdb(\"file.pdb\",\"protein\")orarginines = read_pdb(\"file.pdb\",\"resname ARG\")Instead of the selection strings, a Julia function can be provided, for greater flexibility: arginines = read_pdb(\"file.pdb\", atom -> atom.resname == \"ARG\")The same is valid for the write function, below. ","category":"page"},{"location":"readwrite/#field_assignment","page":"Read and Write","title":"Atom field assignment in mmCIF files","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"By default, the assignment of the _atom_site fields of the mmCIF format to the fields of the Atom data structure  follows the standard mmCIF convention:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"Dict{String,Symbol}(\n    \"id\" => :index_pdb\n    \"Cartn_x\" => :x\n    \"Cartn_y\" => :y\n    \"Cartn_z\" => :z\n    \"occupancy\" => :occup\n    \"B_iso_or_equiv\" => :beta\n    \"pdbx_formal_charge\" => :charge\n    \"pdbx_PDB_model_num\" => :model\n    \"label_atom_id\" => :name\n    \"label_comp_id\" => :resname\n    \"label_asym_id\" => :chain\n    \"auth_seq_id\" => :resnum\n    \"type_symbol\" => :pdb_element\n)","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"This assignment can be customized by providing the field_assignment keyword parameter to the read_mmcif function.  In the following example, we exemplify the possibility of reading _atom_site.type_symbol field of the mmCIF file into the name field of the atom data structure:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> using PDBTools\n\njulia> ats = read_mmcif(PDBTools.TESTCIF, \"index <= 5\");\n\njulia> name.(ats)\n5-element Vector{InlineStrings.String7}:\n \"N\"\n \"CA\"\n \"C\"\n \"O\"\n \"N\"\n\njulia> ats = read_mmcif(PDBTools.TESTCIF, \"index <= 5\"; \n           field_assignment=Dict(\"type_symbol\" => :name)\n        );\n\njulia> name.(ats)\n5-element Vector{InlineStrings.String7}:\n \"N\"\n \"C\"\n \"C\"\n \"O\"\n \"N\"\n","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"The custom entries set in the field_assignment keyword will overwrite the default  assignments for entries sharing keys or fields. For instance, in the example above, the label_atom_id fields which is by default assigned to :name is not being read anymore.","category":"page"},{"location":"readwrite/#Get-structure-from-the-Protein-Data-Bank","page":"Read and Write","title":"Get structure from the Protein Data Bank","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"Use the wget function to retrieve the atom data directly from the PDB database, optionally filtering the atoms with a selection:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> atoms = wget(\"1LBD\",\"name CA\")\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       2   CA     SER     A      225        1   46.080   83.165   70.327 68.73  1.00     1       -         2\n       8   CA     ALA     A      226        2   43.020   80.825   70.455 63.69  1.00     1       -         8\n      13   CA     ASN     A      227        3   41.052   82.178   67.504 53.45  1.00     1       -        13\n                                                       ⋮\n    1847   CA     GLN     A      460      236  -22.650   79.082   50.023 71.46  1.00     1       -      1847\n    1856   CA     MET     A      461      237  -25.561   77.191   51.710 78.41  1.00     1       -      1856\n    1864   CA     THR     A      462      238  -26.915   73.645   51.198 82.96  1.00     1       -      1864","category":"page"},{"location":"readwrite/#PDBTools.wget","page":"Read and Write","title":"PDBTools.wget","text":"wget(PDBid; selection; format=\"mmCIF\")\n\nRetrieves a PDB file from the protein data bank. Selections may be applied.\n\nThe optional format argument can be either \"mmCIF\" or \"PDB\". The default is \"mmCIF\". To download the data of large structures, it is recommended to use the \"mmCIF\" format.\n\nExample\n\njulia> using PDBTools\n\njulia> protein = wget(\"1LBD\",\"chain A\")\n   Vector{Atom{Nothing}} with 1870 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     SER     A      225        1   45.228   84.358   70.638  1.00 67.05     1                 1\n       2   CA     SER     A      225        1   46.080   83.165   70.327  1.00 68.73     1                 2\n⋮\n    1869  CG2     THR     A      462      238  -27.063   71.965   49.222  1.00 78.62     1              1869\n    1870  OXT     THR     A      462      238  -25.379   71.816   51.613  1.00 84.35     1              1870\n\n\n\n\n\n\n","category":"function"},{"location":"readwrite/#Write-a-PDB/mmCIF-file","page":"Read and Write","title":"Write a PDB/mmCIF file","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"To write a PDB file use the write_pdb function, as:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"write_pdb(\"file.pdb\", atoms)","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"where atoms contain a list of atoms with the Atom structures.","category":"page"},{"location":"readwrite/#PDBTools.write_pdb","page":"Read and Write","title":"PDBTools.write_pdb","text":"write_pdb(filename::String, atoms::AbstractVector{<:Atom}, [selection]; header=:auto, footer=:auto, append=false)\n\nWrite a PDB file with the atoms in atoms to filename. The selection argument is a string or function that can be used to select a subset of the atoms in atoms. For example, write_pdb(\"test.pdb\", atoms, \"name CA\").\n\nArguments\n\nfilename::String: The name of the file to write.\natoms::AbstractVector{<:Atom}: The atoms to write to the file.\n\nOptional positional argument\n\nselection::String: A selection string to select a subset of the atoms in atoms.\n\nKeyword arguments\n\nheader::Union{String, Nothing}=:auto: The header to add to the PDB file. If :auto, a header will be added with the number of atoms in atoms.\nfooter::Union{String, Nothing}=:auto: The footer to add to the PDB file. If :auto, a footer will be added with the \"END\" keyword.\nappend::Bool=false: If true, the atoms will be appended to the file instead of overwriting it.\n\n\n\n\n\n","category":"function"},{"location":"readwrite/#PDBTools.write_mmcif","page":"Read and Write","title":"PDBTools.write_mmcif","text":"write_mmcif(filename, atoms::AbstractVector{<:Atom}, [selection]; field_assignment=nothing)\n\nWrite a mmCIF file with the atoms in atoms to filename. The optional selection argument is a string or function that can be used to select a subset of the atoms in atoms. For example, write_mmcif(atoms, \"test.cif\", \"name CA\").\n\nThe optional field_assignment argument is a dictionary that can be used to assign custom fields to the mmCIF file.\n\n\n\n\n\n","category":"function"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"The use of the field_assignment keyword, as explained in the field assignment section is possible in the call to write_mmcif. ","category":"page"},{"location":"readwrite/#Read-from-string-buffer","page":"Read and Write","title":"Read from string buffer","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"In some cases a PDB file data may be available as a string and not a regular file. For example, when reading the output of a zipped file. In these cases, it is possible to obtain the array of atoms by reading directly the string buffer with, for example:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> using PDBTools\n\njulia> pdbdata = read(PDBTools.TESTPDB, String); # returns a string with the PDB data, to exemplify\n\njulia> atoms = read_pdb(IOBuffer(pdbdata), \"protein and name CA\")\n   Vector{Atom{Nothing}} with 104 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       5   CA     ALA     A        1        1   -8.483  -14.912   -6.726  1.00  0.00     1    PROT         5\n      15   CA     CYS     A        2        2   -5.113  -13.737   -5.466  1.00  0.00     1    PROT        15\n⋮\n    1440   CA     CYS     A      103      103    4.134   -7.811   -6.344  1.00  0.00     1    PROT      1440\n    1454   CA     THR     A      104      104    3.244  -10.715   -8.603  1.00  0.00     1    PROT      1454","category":"page"},{"location":"readwrite/#Edit-a-Vector{:Atom}-object","page":"Read and Write","title":"Edit a Vector{<:Atom} object","text":"","category":"section"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"The Atom structure is mutable, meaning that the fields can be edited. For example:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> using PDBTools\n\njulia> atoms = read_pdb(PDBTools.TESTPDB)\n   Vector{Atom{Nothing}} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n⋮\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  1.00  0.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  1.00  0.00     1    WAT2     62026\n\njulia> atoms[1].segname = \"ABCD\"\n\"ABCD\"\n\njulia> printatom(atoms[1])\n   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    ABCD         1","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"Additionally, With the edit! function, you can directly edit or view the data in a vector of Atoms in your preferred text editor. ","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> edit!(atoms)","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"This will open a text editor. Here, we modified the data in the resname field of the first atom to ABC. Saving and closing the file will update the atoms array:","category":"page"},{"location":"readwrite/","page":"Read and Write","title":"Read and Write","text":"julia> printatom(atoms[1])\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1    N     ABC     A        1        1   -9.229  -14.861   -5.481  0.00  1.00     1    PROT         1","category":"page"},{"location":"readwrite/#PDBTools.edit!","page":"Read and Write","title":"PDBTools.edit!","text":"edit!(atoms::AbstractVector{<:Atom})\n\nOpens a temporary PDB file in which the fields of the vector of atoms can be edited.   \n\n\n\n\n\n","category":"function"},{"location":"#PDBTools","page":"Home","title":"PDBTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PDBTools is a simple package to read and write Protein Data Bank files, select atoms, and work with their coordinates. It is aimed to provide support for the typical uses of structure files in the context of molecular dynamics simulations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As of version 2.0, PDBTools is able to read and write the atomic data  from PDB and mmCIF structure files.","category":"page"},{"location":"#Features:","page":"Home","title":"Features:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simple data structure: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> printatom(atoms[1])\n  index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n      1   OW     SOL     X        1        1   54.370   45.310   33.970  0.00  0.00     1       -         1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Selection syntax:","category":"page"},{"location":"","page":"Home","title":"Home","text":"resname ARG and name CA","category":"page"},{"location":"","page":"Home","title":"Home","text":"Allows use of Julia (possibly user-defined) functions for selection:","category":"page"},{"location":"","page":"Home","title":"Home","text":"atom -> ( atom.resname == \"ARG\" && atom.x < 10 ) || atom.name == \"N\"","category":"page"},{"location":"#Not-indicated-for:","page":"Home","title":"Not indicated for:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PDBTools is not very strict in following the PDB or mmCIF formats. In particular, it does not read any of the meta-data of these files, only ATOM and HETATM fields are of interest. Also, it supports repeated atom entries, as each atom is read as  an independent object. This flexibility provides support for common structure formats occurring in the Molecular Dynamics Simulations field. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If more comprehensive (and strict) support for these files is necessary, use the packages of  BioJulia,  BioStructures in particular.","category":"page"}]
}
