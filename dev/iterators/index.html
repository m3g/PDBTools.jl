<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Iterators · PDBTools.jl</title><meta name="title" content="Iterators · PDBTools.jl"/><meta property="og:title" content="Iterators · PDBTools.jl"/><meta property="twitter:title" content="Iterators · PDBTools.jl"/><meta name="description" content="Documentation for PDBTools.jl."/><meta property="og:description" content="Documentation for PDBTools.jl."/><meta property="twitter:description" content="Documentation for PDBTools.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PDBTools.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PDBTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../readwrite/">Read and Write</a></li><li><a class="tocitem" href="../selections/">Selections</a></li><li class="is-active"><a class="tocitem" href>Iterators</a><ul class="internal"><li><a class="tocitem" href="#Iterate-over-residues-(or-molecules)"><span>Iterate over residues (or molecules)</span></a></li><li><a class="tocitem" href="#Iterate-over-chains"><span>Iterate over chains</span></a></li><li><a class="tocitem" href="#Iterate-over-segments"><span>Iterate over segments</span></a></li><li><a class="tocitem" href="#Iterate-over-models"><span>Iterate over models</span></a></li></ul></li><li><a class="tocitem" href="../elements/">Atom and element properties</a></li><li><a class="tocitem" href="../contacts/">Contact maps</a></li><li><a class="tocitem" href="../dihedrals/">Dihderals and Ramachandran</a></li><li><a class="tocitem" href="../auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../help/">Help entries</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Iterators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Iterators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/m3g/PDBTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/m3g/PDBTools.jl/blob/main/docs/src/iterators.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Iterators"><a class="docs-heading-anchor" href="#Iterators">Iterators</a><a id="Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Iterators" title="Permalink"></a></h1><p>PDBTools.jl provides lazy iterators over Residues, Chains, Segments, and Models of a structure file. The iterators behave similarly, and can be used bo computed properties of independent structural elements. The documentation bellow exemplifies in more detail the features associated to Residue and Chain interators, but the properties and valid for Segment and Model iterators similarly.</p><h2 id="Iterate-over-residues-(or-molecules)"><a class="docs-heading-anchor" href="#Iterate-over-residues-(or-molecules)">Iterate over residues (or molecules)</a><a id="Iterate-over-residues-(or-molecules)-1"></a><a class="docs-heading-anchor-permalink" href="#Iterate-over-residues-(or-molecules)" title="Permalink"></a></h2><p>The <code>eachresidue</code> iterator enables iteration over the residues of a structure. In PDB files, distinct molecules are often treated as separate residues, so this iterator can be used to iterate over the molecules within a structure. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; protein = read_pdb(PDBTools.SMALLPDB);

julia&gt; count(atom -&gt; resname(atom) == &quot;ALA&quot;, protein)
12

julia&gt; count(res -&gt; resname(res) == &quot;ALA&quot;, eachresidue(protein))
1</code></pre><p>Here, the first <code>count</code> counts the number of atoms with the residue name &quot;ALA&quot;, while the second uses <code>eachresidue</code> to count the number of residues named &quot;ALA&quot;. This highlights the distinction between residue-level and atom-level operations.</p><h3 id="Collecting-Residues-into-a-Vector"><a class="docs-heading-anchor" href="#Collecting-Residues-into-a-Vector">Collecting Residues into a Vector</a><a id="Collecting-Residues-into-a-Vector-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-Residues-into-a-Vector" title="Permalink"></a></h3><p>Residues produced by <code>eachresidue</code> can be collected into a vector for further processing:</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; protein = read_pdb(PDBTools.SMALLPDB);

julia&gt; residues = collect(eachresidue(protein))
3-element Vector{Residue}[
    ALA1A
    CYS2A
    ASP3A
]

julia&gt; residues[1]
 Residue of name ALA with 12 atoms.
   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb
       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  0.00     1    PROT         1
       2 1HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2
⋮
      11    C     ALA     A        1        1   -7.227  -14.047   -6.599  1.00  0.00     1    PROT        11
      12    O     ALA     A        1        1   -7.083  -13.048   -7.303  1.00  0.00     1    PROT        12</code></pre><div class="admonition is-info" id="Note-c62b9834316f97f1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c62b9834316f97f1" title="Permalink"></a></header><div class="admonition-body"><p>Iterators or collected vectors <em>do not</em> create copies of the original atom data. This means that any changes made to the residue vector will directly modify the corresponding data in the original atom vector.</p></div></div><h3 id="Iterating-Over-Atoms-Within-Residues"><a class="docs-heading-anchor" href="#Iterating-Over-Atoms-Within-Residues">Iterating Over Atoms Within Residues</a><a id="Iterating-Over-Atoms-Within-Residues-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating-Over-Atoms-Within-Residues" title="Permalink"></a></h3><p>You can iterate over the atoms of one or more residues using nested loops. Here, we compute the total number of atoms of ALA residues: </p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; protein = read_pdb(PDBTools.SMALLPDB);

julia&gt; n_ala_cys = 0
       for residue in eachresidue(protein)
            if name(residue) in (&quot;ALA&quot;, &quot;CYS&quot;)
                for atom in residue
                   n_ala_cys += 1
                end
            end
       end
       n_ala_cys
23</code></pre><p>This method produces the same result as the more concise approach:</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; protein = read_pdb(PDBTools.SMALLPDB);

julia&gt; sum(length(r) for r in eachresidue(protein) if name(r) in (&quot;ALA&quot;, &quot;CYS&quot;))
23</code></pre><h3 id="Reference-documentation"><a class="docs-heading-anchor" href="#Reference-documentation">Reference documentation</a><a id="Reference-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-documentation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.Residue" href="#PDBTools.Residue"><code>PDBTools.Residue</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Residue</code></pre><p>Residue data structure. </p><p>The Residue structure carries the properties of the residue or molecule of the atoms it contains, but it does not copy the original vector of atoms, only the residue meta data for each residue. Thus, changes in the residue atoms will be reflected in the original vector of atoms.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; pdb = wget(&quot;1LBD&quot;);

julia&gt; residues = collect(eachresidue(pdb))
238-element Vector{Residue}[
    SER225A
    ALA226A
    ⋮
    MET461A
    THR462A
]

julia&gt; resnum.(residues[1:3])
3-element Vector{Int32}:
 225
 226
 227

julia&gt; residues[5].chain
&quot;A&quot;

julia&gt; residues[8].range
52:58

julia&gt; mass(residues[1])
82.0385f0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/struct_and_iterators/Residue.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.eachresidue" href="#PDBTools.eachresidue"><code>PDBTools.eachresidue</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachresidue(atoms::AbstractVector{&lt;:Atom})</code></pre><p>Iterator for the residues (or molecules) of a selection. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; atoms = wget(&quot;1LBD&quot;);

julia&gt; eachresidue(atoms)
 Residue iterator with length = 238

julia&gt; collect(eachresidue(atoms))
238-element Vector{Residue}[
    SER225A
    ALA226A
    ⋮
    MET461A
    THR462A
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/struct_and_iterators/Residue.jl#L150-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.resname" href="#PDBTools.resname"><code>PDBTools.resname</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resname(residue::Union{AbstractString,Char})</code></pre><p>Returns the residue name, given the one-letter code or residue name. Differently from <code>threeletter</code>, this function will return the force-field name if available in the list of protein residues.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; resname(&quot;ALA&quot;)
&quot;ALA&quot;

julia&gt; resname(&quot;GLUP&quot;)
&quot;GLUP&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/properties/protein_residues.jl#L147-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.residuename" href="#PDBTools.residuename"><code>PDBTools.residuename</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residuename(residue::Union{AbstractString,Char})</code></pre><p>Function to return the long residue name from other residue codes. The function is case-insensitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; residuename(&quot;A&quot;)
&quot;Alanine&quot;

julia&gt; residuename(&quot;Glu&quot;)
&quot;Glutamic Acid&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/properties/protein_residues.jl#L182-L198">source</a></section></article><h2 id="Iterate-over-chains"><a class="docs-heading-anchor" href="#Iterate-over-chains">Iterate over chains</a><a id="Iterate-over-chains-1"></a><a class="docs-heading-anchor-permalink" href="#Iterate-over-chains" title="Permalink"></a></h2><p>The <code>eachchain</code> iterator in PDBTools enables users to iterate over the chains in a PDB structure. A PDB file may contain multiple protein chains. This iterator simplifies operations involving individual chains.</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.CHAINSPDB);

julia&gt; chain.(eachchain(ats)) # Retrieve the names of all chains in the structure
4-element Vector{InlineStrings.String3}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;A&quot;
 &quot;D&quot;

julia&gt; model.(eachchain(ats)) # Retrieve the model numbers associated with each chain
4-element Vector{Int32}:
 1
 1
 1
 2

julia&gt; chain_A1 = first(eachchain(ats)); # Access the first chain in the iterator

julia&gt; resname.(eachresidue(chain_A1)) # Retrieve residue names for chain A in model 1
3-element Vector{InlineStrings.String7}:
 &quot;ASP&quot;
 &quot;GLN&quot;
 &quot;LEU&quot;
</code></pre><p>In the example above, the <code>chain.</code> command retrieves the names of all chains in the structure, while  <code>model.</code> command lists the model numbers for each chain. This PDB structure contains two models for chain A, where the third residue changes from leucine (LEU) in model 1 to valine (VAL) in model 2.</p><h3 id="Accessing-Chains-by-Index"><a class="docs-heading-anchor" href="#Accessing-Chains-by-Index">Accessing Chains by Index</a><a id="Accessing-Chains-by-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Chains-by-Index" title="Permalink"></a></h3><p>As seen in the previous example, The <code>first</code> and <code>last</code> commands allow quick access to the first an last elements in the iterator. For more specific indexing, you can collect all chains into an array and then use numerical indices to access them.</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.CHAINSPDB);

julia&gt; chains = collect(eachchain(ats))
4-element Vector{Chain}[
    Chain(A-48 atoms)
    Chain(B-48 atoms)
    Chain(A-48 atoms)
    Chain(D-45 atoms)
]

julia&gt; chain_B = chains[2]
 Chain B with 48 atoms.
   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb
      49    N     ASP     B        4        4  135.661  123.866  -22.311  1.00  0.00     1    ASYN        49
      50   CA     ASP     B        4        4  136.539  123.410  -21.227  1.00  0.00     1    ASYN        50
⋮
      95 HD23     LEU     B        6        6  138.780  120.216  -17.864  1.00  0.00     1    ASYN        95
      96    O     LEU     B        6        6  141.411  117.975  -21.923  1.00  0.00     1    ASYN        96
</code></pre><h3 id="Modifying-Atom-Properties-in-a-Chain"><a class="docs-heading-anchor" href="#Modifying-Atom-Properties-in-a-Chain">Modifying Atom Properties in a Chain</a><a id="Modifying-Atom-Properties-in-a-Chain-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-Atom-Properties-in-a-Chain" title="Permalink"></a></h3><p>Any changes made to the atoms of a chain variable directly overwrite the properties of the original atoms in the structure. For example, modifying the occupancy and beta-factor columns of atoms in model 2 of chain A will update the corresponding properties in the original structure.</p><p>In the example below, the <code>occup</code> and <code>beta</code> properties of all atoms in model 2 of chain A are set to 0.00. The changes are reflected in the original <code>ats</code> vector, demonstrating that the modifications propagate to the parent data structure.</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.CHAINSPDB);

julia&gt; first(eachchain(ats))
 Chain A with 48 atoms.
   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb
       1    N     ASP     A        1        1  133.978  119.386  -23.646  1.00  0.00     1    ASYN         1
       2   CA     ASP     A        1        1  134.755  118.916  -22.497  1.00  0.00     1    ASYN         2
⋮
      47 HD23     LEU     A        3        3  130.568  111.868  -26.242  1.00  0.00     1    ASYN        47
      48    O     LEU     A        3        3  132.066  112.711  -21.739  1.00  0.00     1    ASYN        48

 
julia&gt; for chain in eachchain(ats)
           if name(chain) == &quot;A&quot; &amp;&amp; model(chain) == 2
               for atom in chain
                   atom.occup = 0.00
                   atom.beta = 0.00
               end
           end
       end

julia&gt; first(eachchain(ats))
 Chain A with 48 atoms.
   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb
       1    N     ASP     A        1        1  133.978  119.386  -23.646  1.00  0.00     1    ASYN         1
       2   CA     ASP     A        1        1  134.755  118.916  -22.497  1.00  0.00     1    ASYN         2
⋮
      47 HD23     LEU     A        3        3  130.568  111.868  -26.242  1.00  0.00     1    ASYN        47
      48    O     LEU     A        3        3  132.066  112.711  -21.739  1.00  0.00     1    ASYN        48
</code></pre><p>This behavior ensures efficient data manipulation but requires careful handling to avoid unintended changes. </p><h3 id="Reference-documentation-2"><a class="docs-heading-anchor" href="#Reference-documentation-2">Reference documentation</a><a class="docs-heading-anchor-permalink" href="#Reference-documentation-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.Chain" href="#PDBTools.Chain"><code>PDBTools.Chain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Chain</code></pre><p>Creates a Chain data structure. Chains must be consecutive in the <code>atoms</code> vector, and are identified by having the same <code>chain</code>, <code>segment</code>, and <code>model</code> fields.</p><p>The Chain structure carries the properties of the atoms it contains, but it does not copy the original vector of atoms. This means that any changes made in the Chain structure atoms, will overwrite the original vector of atoms. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.CHAINSPDB);

julia&gt; chains = collect(eachchain(ats))
4-element Vector{Chain}[
    Chain(A-48 atoms)
    Chain(B-48 atoms)
    Chain(A-48 atoms)
    Chain(D-45 atoms)
]

julia&gt; chains[1]
 Chain A with 48 atoms.
   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb
       1    N     ASP     A        1        1  133.978  119.386  -23.646  1.00  0.00     1    ASYN         1
       2   CA     ASP     A        1        1  134.755  118.916  -22.497  1.00  0.00     1    ASYN         2
⋮
      47 HD23     LEU     A        3        3  130.568  111.868  -26.242  1.00  0.00     1    ASYN        47
      48    O     LEU     A        3        3  132.066  112.711  -21.739  1.00  0.00     1    ASYN        48

julia&gt; mass(chains[1])
353.3787f0 

julia&gt; model(chains[4])
2

julia&gt; segname(chains[2])
&quot;ASYN&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/struct_and_iterators/Chain.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.eachchain" href="#PDBTools.eachchain"><code>PDBTools.eachchain</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachchain(atoms::AbstractVector{&lt;:Atom})</code></pre><p>Iterator for the chains of a selection. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.CHAINSPDB);

julia&gt; eachchain(ats)
 Chain iterator with length = 4

julia&gt; chains = collect(eachchain(ats))
4-element Vector{Chain}[
    Chain(A-48 atoms)
    Chain(B-48 atoms)
    Chain(A-48 atoms)
    Chain(D-45 atoms)
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/struct_and_iterators/Chain.jl#L67-L91">source</a></section></article><h2 id="Iterate-over-segments"><a class="docs-heading-anchor" href="#Iterate-over-segments">Iterate over segments</a><a id="Iterate-over-segments-1"></a><a class="docs-heading-anchor-permalink" href="#Iterate-over-segments" title="Permalink"></a></h2><p>The <code>eachsegment</code> iterator enables iteration over the segments of a structure. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.DIMERPDB);

julia&gt; eachsegment(ats)
 Segment iterator with length = 2

julia&gt; name.(eachsegment(ats))
2-element Vector{InlineStrings.String7}:
 &quot;A&quot;
 &quot;B&quot;</code></pre><p>The result of the iterator can also be collected, with:</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.DIMERPDB);

julia&gt; s = collect(eachsegment(ats))
2-element Vector{Segment}[ 
    A-(1905 atoms))
    B-(92 atoms))
]

julia&gt; s[1]
 Segment of name A with 1905 atoms.
   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb
       1    N     LYS     A      211        1   52.884   24.022   35.587  1.00 53.10     1       A         1
       2   CA     LYS     A      211        1   52.916   24.598   36.993  1.00 53.10     1       A         2
⋮
    1904  OD2     ASP     A      461      243   17.538   51.009   45.748  1.00 97.43     1       A      1904
    1905  OXT     ASP     A      461      243   14.506   47.082   47.528  1.00 97.43     1       A      1905</code></pre><p>These segment structure <em>does not</em> copy the data from the original atom vector. Therefore, changes performed on these vectors will be reflected on the original data.  </p><p>Iterators can be used to obtain or modify properties of the segments. Here we illustrate computing the mass of each segment and renaming segment of all atoms with the segment indices:</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.DIMERPDB);

julia&gt; s = collect(eachsegment(ats))
2-element Vector{Segment}[ 
    A-(1905 atoms))
    B-(92 atoms))
]

julia&gt; mass.(s)
2-element Vector{Float32}:
 25222.553
  1210.7296

julia&gt; for (iseg, seg) in enumerate(eachsegment(ats))
           for at in seg
               at.segname = &quot;$(at.segname)$iseg&quot;
           end
       end

julia&gt; collect(eachsegment(ats))
2-element Vector{Segment}[ 
    A1-(1905 atoms))
    B2-(92 atoms))
]</code></pre><h3 id="Reference-documentation-3"><a class="docs-heading-anchor" href="#Reference-documentation-3">Reference documentation</a><a class="docs-heading-anchor-permalink" href="#Reference-documentation-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.Segment" href="#PDBTools.Segment"><code>PDBTools.Segment</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Segment</code></pre><p>Segment data structure. Segments must be consecutive in the <code>atoms</code> vector, and are identified by having the same <code>segname</code> and <code>model</code> fields.</p><p>The Segment structure carries the properties of the segment  it contains, but it does not copy the original vector of atoms, only the segment meta data and the reference to the original vector. Thus, changes in the segment atoms will be reflected in the original vector of atoms.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.DIMERPDB);

julia&gt; segments = collect(eachsegment(ats))
2-element Vector{Segment}[
    A-(1905 atoms))
    B-(92 atoms))
]

julia&gt; segname.(segments[1:2])
2-element Vector{InlineStrings.String7}:
 &quot;A&quot;
 &quot;B&quot;

julia&gt; length(segments[2])
92
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/struct_and_iterators/Segment.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.eachsegment" href="#PDBTools.eachsegment"><code>PDBTools.eachsegment</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachsegment(atoms::AbstractVector{&lt;:Atom})</code></pre><p>Iterator for the segments of a selection.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = read_pdb(PDBTools.DIMERPDB);

julia&gt; sit = eachsegment(ats)
 Segment iterator with length = 2

julia&gt; for seg in sit
           @show length(seg)
       end
length(seg) = 1905
length(seg) = 92

julia&gt; collect(sit)
2-element Vector{Segment}[ 
    A-(1905 atoms))
    B-(92 atoms))
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/struct_and_iterators/Segment.jl#L52-L80">source</a></section></article><h2 id="Iterate-over-models"><a class="docs-heading-anchor" href="#Iterate-over-models">Iterate over models</a><a id="Iterate-over-models-1"></a><a class="docs-heading-anchor-permalink" href="#Iterate-over-models" title="Permalink"></a></h2><p>The <code>eachmodel</code> iterator enables iteration over the segments of a structure. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = wget(&quot;8S8N&quot;);

julia&gt; eachmodel(ats)
 Model iterator with length = 11

julia&gt; model.(eachmodel(ats))
11-element Vector{Int32}:
  1
  2
  3
  ⋮
 10
 11</code></pre><p>The result of the iterator can also be collected, with:</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = wget(&quot;8S8N&quot;);

julia&gt; m = collect(eachmodel(ats))
11-element Vector{Model}[
    1-(234 atoms))
    2-(234 atoms))
    ⋮
    10-(234 atoms))
    11-(234 atoms))
]

julia&gt; m[1]
 Model 1 with 234 atoms.
   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb
       1    N     DLE     A        2        1   -5.811   -0.380   -2.159  1.00  0.00     1                 1
       2   CA     DLE     A        2        1   -4.785   -0.493   -3.227  1.00  0.00     1                 2
⋮
     233  HT2   A1H5T     B      101       13   -5.695    5.959   -3.901  1.00  0.00     1               233
     234  HT1   A1H5T     B      101       13   -4.693    4.974   -2.743  1.00  0.00     1               234</code></pre><p>The model structure <em>does not</em> copy the data from the original atom vector. Therefore, changes performed on these vectors will be reflected on the original data.  </p><p>Iterators can be used to obtain or modify properties of the segments. Here we illustrate computing the mass of each segment and renaming segment of all atoms with the segment indices:</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = wget(&quot;8S8N&quot;);

julia&gt; center_of_mass.(eachmodel(ats))
11-element Vector{StaticArraysCore.SVector{3, Float32}}:
 [0.6337627, -0.14130484, -0.2179606]
 [0.56077266, -0.15154965, 0.1354806]
 [0.5065595, -0.0977174, 0.030405657]
 ⋮
 [0.38899764, -0.21103837, 0.2180245]
 [0.69953984, -0.15372278, 0.21793146]
</code></pre><h3 id="Reference-documentation-4"><a class="docs-heading-anchor" href="#Reference-documentation-4">Reference documentation</a><a class="docs-heading-anchor-permalink" href="#Reference-documentation-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.Model" href="#PDBTools.Model"><code>PDBTools.Model</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Model</code></pre><p>Model data structure. It carries the data of a model in a PDB file. Models must be consecutive in the <code>atoms</code> vector, and are identified by having the same <code>model</code> field.</p><p>The Model structure carries the properties of the model it contains, but it does not copy the original vector of atoms, only the model meta data and the reference to the original vector. Thus, changes in the model atoms will be reflected in the original vector of atoms.</p><p><strong>Example</strong></p><p>In the example below, 8S8N is PDB entry with 11 models.</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = wget(&quot;8S8N&quot;);

julia&gt; models = collect(eachmodel(ats))
11-element Vector{Model}[
    1-(234 atoms))
    2-(234 atoms))
    ⋮
    10-(234 atoms))
    11-(234 atoms))
]

julia&gt; models[1]
 Model 1 with 234 atoms.
   index name resname chain   resnum  residue        x        y        z occup  beta model segname index_pdb
       1    N     DLE     A        2        1   -5.811   -0.380   -2.159  1.00  0.00     1                 1
       2   CA     DLE     A        2        1   -4.785   -0.493   -3.227  1.00  0.00     1                 2
⋮
     233  HT2   A1H5T     B      101       13   -5.695    5.959   -3.901  1.00  0.00     1               233
     234  HT1   A1H5T     B      101       13   -4.693    4.974   -2.743  1.00  0.00     1               234
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/struct_and_iterators/Model.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDBTools.eachmodel" href="#PDBTools.eachmodel"><code>PDBTools.eachmodel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachmodel(atoms::AbstractVector{&lt;:Atom})</code></pre><p>Iterator for the models of a selection.</p><p><strong>Example</strong></p><p>Here we show how to iterate over the models of a PDB file, annotate  the index of the first atom of each model, and collect all models.</p><pre><code class="language-julia-repl hljs">julia&gt; using PDBTools

julia&gt; ats = wget(&quot;8S8N&quot;);

julia&gt; models = eachmodel(ats)
 Model iterator with length = 11

julia&gt; first_atom = Atom[]
       for model in models
           push!(first_atom, model[1])
       end
       @show index.(first_atom);
index.(first_atom) = Int32[1, 235, 469, 703, 937, 1171, 1405, 1639, 1873, 2107, 2341]

julia&gt; collect(models)
11-element Vector{Model}[
    1-(234 atoms))
    2-(234 atoms))
    ⋮
    10-(234 atoms))
    11-(234 atoms))
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/m3g/PDBTools.jl/blob/18109a4dc76b24b3f8c738c286b57f932c17a8e9/src/struct_and_iterators/Model.jl#L62-L97">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../selections/">« Selections</a><a class="docs-footer-nextpage" href="../elements/">Atom and element properties »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 18 October 2025 18:12">Saturday 18 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
